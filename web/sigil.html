<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no"
        />
        <title>Sigil Card — Socialmesh</title>
        <meta
            name="description"
            content="View an animated Socialmesh Sigil Card — a unique geometric identity for a mesh radio node."
        />
        <link rel="icon" type="image/png" href="/favicon.png" />

        <!-- Open Graph -->
        <meta property="og:title" content="Sigil Card — Socialmesh" />
        <meta
            property="og:description"
            content="View an animated mesh node identity card on Socialmesh."
        />
        <meta property="og:type" content="website" />
        <meta property="og:image" content="/images/app-icon.png" />

        <style>
            @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700;800&display=swap");

            *,
            *::before,
            *::after {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            :root {
                --bg-deep: #0a0e14;
                --bg-primary: #1f2633;
                --bg-card: #0d1117;
                --text-primary: #e8ecf1;
                --text-secondary: #9ca3af;
                --text-tertiary: #6b7280;
                --accent-magenta: #e91e8c;
                --font-family:
                    "JetBrains Mono", "SF Mono", "Fira Code", monospace;
            }

            html,
            body {
                width: 100%;
                min-height: 100vh;
                background: var(--bg-deep);
                color: var(--text-primary);
                font-family: var(--font-family);
                overflow-x: hidden;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            body {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                padding: 24px 16px;
                background:
                    radial-gradient(
                        ellipse at 50% 30%,
                        rgba(139, 92, 246, 0.06) 0%,
                        transparent 60%
                    ),
                    radial-gradient(
                        ellipse at 20% 80%,
                        rgba(14, 165, 233, 0.04) 0%,
                        transparent 50%
                    ),
                    var(--bg-deep);
            }

            /* ============================================================ */
            /* Card Container                                                */
            /* ============================================================ */

            .card-wrapper {
                position: relative;
                width: 340px;
                max-width: calc(100vw - 32px);
                aspect-ratio: 5 / 7;
                perspective: 1200px;
            }

            .card {
                position: relative;
                width: 100%;
                height: 100%;
                border-radius: 14px;
                overflow: hidden;
                background: var(--bg-card);
                display: flex;
                flex-direction: column;
                transition: transform 0.3s ease;
            }

            .card:hover {
                transform: translateY(-2px);
            }

            .card-border {
                position: absolute;
                inset: 0;
                border-radius: 14px;
                pointer-events: none;
                z-index: 10;
            }

            .card-inner-highlight {
                position: absolute;
                inset: 0;
                border-radius: 14px;
                pointer-events: none;
                z-index: 11;
            }

            .card-glow {
                position: absolute;
                inset: -8px;
                border-radius: 22px;
                pointer-events: none;
                z-index: -1;
                opacity: 0;
                transition: opacity 0.3s;
            }

            .card-wrapper:hover .card-glow {
                opacity: 1;
            }

            /* Background layers */
            .card-bg {
                position: absolute;
                inset: 0;
                z-index: 0;
            }

            .card-bg canvas {
                width: 100%;
                height: 100%;
            }

            .card-content {
                position: relative;
                z-index: 1;
                display: flex;
                flex-direction: column;
                height: 100%;
            }

            /* ============================================================ */
            /* Trait Banner                                                   */
            /* ============================================================ */

            .trait-banner {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 8px 14px 4px;
            }

            .trait-badge {
                display: flex;
                align-items: center;
                gap: 5px;
                padding: 3px 8px;
                border-radius: 6px;
                font-size: 9px;
                font-weight: 700;
                letter-spacing: 1.2px;
                text-transform: uppercase;
            }

            .trait-icon {
                width: 10px;
                height: 10px;
                border-radius: 50%;
            }

            .role-label {
                font-size: 8px;
                font-weight: 600;
                letter-spacing: 0.8px;
                text-transform: uppercase;
                opacity: 0.4;
            }

            /* ============================================================ */
            /* Sigil Hero                                                    */
            /* ============================================================ */

            .sigil-hero {
                flex: 9;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                min-height: 0;
            }

            .sigil-canvas-wrap {
                position: relative;
                width: 70%;
                aspect-ratio: 1;
            }

            #sigil-canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            .sigil-glow {
                position: absolute;
                inset: 10%;
                border-radius: 50%;
                pointer-events: none;
                filter: blur(30px);
                opacity: 0.15;
            }

            /* Orbit ring for rare+ */
            .orbit-ring {
                position: absolute;
                inset: -2%;
                border-radius: 50%;
                border: 1px solid transparent;
                pointer-events: none;
                animation: orbit-spin 20s linear infinite;
            }

            @keyframes orbit-spin {
                from {
                    transform: rotate(0deg);
                }
                to {
                    transform: rotate(360deg);
                }
            }

            /* ============================================================ */
            /* Name Plate                                                    */
            /* ============================================================ */

            .name-plate {
                text-align: center;
                padding: 0 14px;
            }

            .node-name {
                font-size: 16px;
                font-weight: 700;
                letter-spacing: 0.5px;
                line-height: 1.2;
                text-shadow: 0 1px 8px rgba(0, 0, 0, 0.5);
                word-break: break-word;
            }

            .node-hex-id {
                font-size: 9px;
                font-weight: 500;
                letter-spacing: 1px;
                opacity: 0.5;
                margin-top: 2px;
            }

            /* ============================================================ */
            /* Ornament Divider                                               */
            /* ============================================================ */

            .ornament-divider {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 6px 14px;
                gap: 6px;
            }

            .ornament-line {
                flex: 1;
                height: 1px;
                opacity: 0.2;
            }

            .ornament-diamond {
                width: 5px;
                height: 5px;
                transform: rotate(45deg);
                opacity: 0.4;
            }

            /* ============================================================ */
            /* Stats Grid                                                    */
            /* ============================================================ */

            .stats-grid {
                flex: 5;
                display: flex;
                flex-direction: column;
                justify-content: center;
                padding: 2px 14px;
                gap: 4px;
                min-height: 0;
            }

            .stats-row {
                display: flex;
                gap: 4px;
            }

            .stat-cell {
                flex: 1;
                text-align: center;
                padding: 4px 2px;
                border-radius: 6px;
                background: rgba(255, 255, 255, 0.03);
                border: 1px solid rgba(255, 255, 255, 0.05);
                transition: background 0.2s;
            }

            .stat-cell.highlight {
                background: rgba(255, 255, 255, 0.06);
                border-color: rgba(255, 255, 255, 0.08);
            }

            .stat-value {
                font-size: 13px;
                font-weight: 700;
                line-height: 1.2;
            }

            .stat-label {
                font-size: 7px;
                font-weight: 600;
                letter-spacing: 1px;
                opacity: 0.4;
                margin-top: 1px;
            }

            /* ============================================================ */
            /* Device & Palette Line                                          */
            /* ============================================================ */

            .device-palette-line {
                display: flex;
                align-items: center;
                padding: 3px 14px;
            }

            .palette-dots {
                display: flex;
                gap: 3px;
            }

            .palette-dot {
                width: 7px;
                height: 7px;
                border-radius: 50%;
                border: 0.5px solid rgba(255, 255, 255, 0.12);
            }

            .device-text {
                flex: 1;
                text-align: right;
                font-size: 7.5px;
                font-weight: 500;
                color: rgba(255, 255, 255, 0.3);
                letter-spacing: 0.3px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                margin-left: 8px;
            }

            /* ============================================================ */
            /* Brand Footer                                                  */
            /* ============================================================ */

            .brand-footer {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 6px 14px;
                border-top: 0.5px solid rgba(255, 255, 255, 0.08);
                background: linear-gradient(
                    to bottom,
                    rgba(255, 255, 255, 0.01),
                    rgba(13, 17, 23, 0.3)
                );
            }

            .brand-mark {
                display: flex;
                align-items: center;
                gap: 3px;
                font-size: 6.5px;
                font-weight: 700;
                color: rgba(255, 255, 255, 0.25);
                letter-spacing: 1.5px;
            }

            .brand-hex {
                width: 9px;
                height: 9px;
                opacity: 0.25;
            }

            .rarity-label {
                font-size: 7px;
                font-weight: 800;
                letter-spacing: 1px;
            }

            .discovery-date {
                font-size: 6.5px;
                font-weight: 500;
                color: rgba(255, 255, 255, 0.25);
            }

            /* ============================================================ */
            /* CTA / App Promo                                               */
            /* ============================================================ */

            .app-promo {
                margin-top: 32px;
                text-align: center;
                max-width: 340px;
            }

            .app-promo h2 {
                font-size: 14px;
                font-weight: 700;
                color: var(--text-primary);
                margin-bottom: 6px;
                letter-spacing: 0.5px;
            }

            .app-promo p {
                font-size: 11px;
                color: var(--text-secondary);
                line-height: 1.5;
                margin-bottom: 16px;
            }

            .store-badges {
                display: flex;
                gap: 12px;
                justify-content: center;
                flex-wrap: wrap;
            }

            .store-badge {
                height: 40px;
                transition:
                    transform 0.2s,
                    opacity 0.2s;
                opacity: 0.85;
            }

            .store-badge:hover {
                transform: scale(1.05);
                opacity: 1;
            }

            /* ============================================================ */
            /* Error State                                                   */
            /* ============================================================ */

            .error-state {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 60vh;
                text-align: center;
                padding: 32px;
            }

            .error-state .icon {
                font-size: 48px;
                margin-bottom: 16px;
                opacity: 0.4;
            }

            .error-state h2 {
                font-size: 18px;
                font-weight: 700;
                margin-bottom: 8px;
                color: var(--text-primary);
            }

            .error-state p {
                font-size: 12px;
                color: var(--text-secondary);
                line-height: 1.6;
                max-width: 300px;
            }

            /* ============================================================ */
            /* Loading State                                                 */
            /* ============================================================ */

            .loading-state {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 60vh;
            }

            .loading-spinner {
                width: 32px;
                height: 32px;
                border: 2.5px solid rgba(255, 255, 255, 0.1);
                border-top-color: var(--accent-magenta);
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
            }

            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }

            .loading-state p {
                margin-top: 16px;
                font-size: 12px;
                color: var(--text-secondary);
            }

            /* ============================================================ */
            /* Responsive                                                    */
            /* ============================================================ */

            @media (max-width: 380px) {
                .card-wrapper {
                    width: 300px;
                }
                .node-name {
                    font-size: 14px;
                }
                .stat-value {
                    font-size: 11px;
                }
            }

            @media (min-width: 500px) {
                .card-wrapper {
                    width: 360px;
                }
            }

            /* Subtle ambient animation on the page background */
            @keyframes ambient-shift {
                0%,
                100% {
                    opacity: 0.06;
                }
                50% {
                    opacity: 0.1;
                }
            }

            body::before {
                content: "";
                position: fixed;
                inset: 0;
                background: radial-gradient(
                    circle at 50% 40%,
                    var(--accent-magenta),
                    transparent 60%
                );
                opacity: 0.04;
                animation: ambient-shift 8s ease-in-out infinite;
                pointer-events: none;
                z-index: 0;
            }

            body > * {
                position: relative;
                z-index: 1;
            }
        </style>
    </head>
    <body>
        <div id="app-root">
            <div class="loading-state" id="loading-state">
                <div class="loading-spinner"></div>
                <p>Decoding sigil&hellip;</p>
            </div>
        </div>

        <script>
            // =========================================================================
            // Sigil Generator — deterministic, ported 1:1 from Dart
            // =========================================================================

            const PALETTE = [
                0xff0ea5e9, // sky
                0xff8b5cf6, // purple
                0xfff97316, // orange
                0xff10b981, // emerald
                0xffef4444, // red
                0xfffbbf24, // amber
                0xff06b6d4, // cyan
                0xffec4899, // pink
                0xff14b8a6, // teal
                0xff6366f1, // indigo
                0xff84cc16, // lime
                0xffa78bfa, // lavender
                0xffe91e8c, // magenta
                0xff22c55e, // green
                0xfff43f5e, // rose
                0xff0369a1, // deep sky
            ];

            function mix(value) {
                let h = value & 0xffffffff;
                h ^= h >>> 16;
                h = Math.imul(h, 0x45d9f3b) & 0xffffffff;
                h ^= h >>> 16;
                h = Math.imul(h, 0x45d9f3b) & 0xffffffff;
                h ^= h >>> 16;
                return h >>> 0; // ensure unsigned
            }

            function extractBits(hash, offset, count) {
                return (hash >>> offset) & ((1 << count) - 1);
            }

            function colorFromInt(c) {
                const a = ((c >>> 24) & 0xff) / 255;
                const r = (c >>> 16) & 0xff;
                const g = (c >>> 8) & 0xff;
                const b = c & 0xff;
                return { r, g, b, a, int: c };
            }

            function colorToCSS(c, alphaOverride) {
                const a = alphaOverride !== undefined ? alphaOverride : c.a;
                return `rgba(${c.r},${c.g},${c.b},${a})`;
            }

            function colorToHex(c) {
                return (
                    "#" +
                    [c.r, c.g, c.b]
                        .map((v) => v.toString(16).padStart(2, "0"))
                        .join("")
                );
            }

            function generateSigil(nodeNum) {
                const h0 = mix(nodeNum);
                const h1 = mix(h0);
                const h2 = mix(h1);
                const h3 = mix(h2);
                const h4 = mix(h3);

                const vertices = 3 + (extractBits(h0, 0, 8) % 6);
                const rotationStep = extractBits(h0, 8, 8) % 24;
                const rotation = rotationStep * ((Math.PI * 2.0) / 24.0);
                const innerRings = extractBits(h1, 0, 8) % 4;
                const drawRadials = extractBits(h1, 8, 8) % 3 !== 0;
                const centerDot = extractBits(h2, 0, 8) % 2 === 0;
                const symmetryFold = 2 + (extractBits(h2, 8, 8) % 5);

                let primaryIndex = extractBits(h3, 0, 8) % PALETTE.length;
                let secondaryIndex = extractBits(h3, 8, 8) % PALETTE.length;
                if (secondaryIndex === primaryIndex) {
                    secondaryIndex = (secondaryIndex + 1) % PALETTE.length;
                }
                let tertiaryIndex = extractBits(h4, 0, 8) % PALETTE.length;
                if (
                    tertiaryIndex === primaryIndex ||
                    tertiaryIndex === secondaryIndex
                ) {
                    tertiaryIndex = (tertiaryIndex + 2) % PALETTE.length;
                }
                if (
                    tertiaryIndex === primaryIndex ||
                    tertiaryIndex === secondaryIndex
                ) {
                    tertiaryIndex = (tertiaryIndex + 1) % PALETTE.length;
                }

                return {
                    vertices,
                    rotation,
                    innerRings,
                    drawRadials,
                    centerDot,
                    symmetryFold,
                    primaryColor: colorFromInt(PALETTE[primaryIndex]),
                    secondaryColor: colorFromInt(PALETTE[secondaryIndex]),
                    tertiaryColor: colorFromInt(PALETTE[tertiaryIndex]),
                };
            }

            // =========================================================================
            // Trait & Rarity System
            // =========================================================================

            const TRAITS = {
                wanderer: {
                    label: "Wanderer",
                    color: colorFromInt(0xff0ea5e9),
                    desc: "Seen across multiple locations",
                },
                beacon: {
                    label: "Beacon",
                    color: colorFromInt(0xfffbbf24),
                    desc: "Always active, high availability",
                },
                ghost: {
                    label: "Ghost",
                    color: colorFromInt(0xff8b5cf6),
                    desc: "Rarely seen, elusive presence",
                },
                sentinel: {
                    label: "Sentinel",
                    color: colorFromInt(0xff10b981),
                    desc: "Fixed position, long-lived guardian",
                },
                relay: {
                    label: "Relay",
                    color: colorFromInt(0xfff97316),
                    desc: "High throughput, forwards traffic",
                },
                unknown: {
                    label: "Unknown",
                    color: colorFromInt(0xff9ca3af),
                    desc: "Recently discovered",
                },
            };

            const RARITY_CONFIG = {
                common: {
                    label: "COMMON",
                    borderColor: colorFromInt(0xff6b7280),
                    glowColor: colorFromInt(0xff6b7280),
                    borderWidth: 1.5,
                    hasGlow: false,
                    glowSpread: 0,
                    glowBlur: 0,
                },
                uncommon: {
                    label: "UNCOMMON",
                    borderColor: colorFromInt(0xff10b981),
                    glowColor: colorFromInt(0xff10b981),
                    borderWidth: 1.5,
                    hasGlow: false,
                    glowSpread: 0,
                    glowBlur: 0,
                },
                rare: {
                    label: "RARE",
                    borderColor: colorFromInt(0xff3b82f6),
                    glowColor: colorFromInt(0xff3b82f6),
                    borderWidth: 2.0,
                    hasGlow: false,
                    glowSpread: 0,
                    glowBlur: 0,
                },
                epic: {
                    label: "EPIC",
                    borderColor: colorFromInt(0xff8b5cf6),
                    glowColor: colorFromInt(0xff8b5cf6),
                    borderWidth: 2.5,
                    hasGlow: true,
                    glowSpread: 4,
                    glowBlur: 12,
                },
                legendary: {
                    label: "LEGENDARY",
                    borderColor: colorFromInt(0xffd4af37),
                    glowColor: colorFromInt(0xffffcc00),
                    borderWidth: 3.0,
                    hasGlow: true,
                    glowSpread: 8,
                    glowBlur: 20,
                },
            };

            function computeRarity(encounterCount, trait) {
                if (encounterCount >= 100) return "legendary";
                if (encounterCount >= 50) return "epic";
                if (encounterCount >= 20) return "rare";
                if (encounterCount >= 5 && trait !== "unknown")
                    return "uncommon";
                return "common";
            }

            // =========================================================================
            // URL Parameter Parsing
            // =========================================================================

            // Sigil API base URL
            // Uses Railway-generated domain until sigil.socialmesh.app DNS propagates.
            const SIGIL_API_URL = "https://sigil-api-production.up.railway.app";

            /**
             * Extract the sigil ID from the URL path.
             * Matches /sigil/{id} or /sigil.html with ?id={id}
             */
            function extractSigilId() {
                // Path-based: /sigil/aBcDeFgHiJ
                const pathMatch = window.location.pathname.match(
                    /\/sigil\/([A-Za-z0-9_-]+)/,
                );
                if (pathMatch) return pathMatch[1];

                // Query fallback: /sigil?id=aBcDeFgHiJ
                const params = new URLSearchParams(window.location.search);
                return params.get("id") || null;
            }

            /**
             * Fetch sigil data from the API by ID.
             * Returns the card data object or null on failure.
             */
            async function fetchSigilData(id) {
                try {
                    const response = await fetch(
                        `${SIGIL_API_URL}/api/sigil/${encodeURIComponent(id)}`,
                    );
                    if (!response.ok) return null;

                    const data = await response.json();
                    if (!data || !data.nodeNum) return null;

                    return {
                        nodeNum: data.nodeNum,
                        displayName: data.displayName || `Node ${data.nodeNum}`,
                        hexId:
                            data.hexId ||
                            "!" +
                                data.nodeNum
                                    .toString(16)
                                    .toUpperCase()
                                    .padStart(4, "0"),
                        trait: data.trait || "unknown",
                        confidence: 0.5,
                        encounterCount: data.encounterCount || 0,
                        maxDistance:
                            data.maxDistance != null ? data.maxDistance : null,
                        messageCount: data.messageCount || 0,
                        bestSnr: data.bestSnr != null ? data.bestSnr : null,
                        coSeenCount: data.coSeenCount || 0,
                        ageDays: data.ageDays || 0,
                        role: data.role || null,
                        hardwareModel: data.hardwareModel || null,
                        firmwareVersion: data.firmwareVersion || null,
                        firstSeen: data.firstSeen || null,
                    };
                } catch (err) {
                    console.error("[sigil] API fetch failed:", err);
                    return null;
                }
            }

            // =========================================================================
            // Sigil Canvas Renderer (animated)
            // =========================================================================

            class SigilRenderer {
                constructor(canvas, sigil, showGlow) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext("2d");
                    this.sigil = sigil;
                    this.showGlow = showGlow;
                    this.opacity = 1.0;
                    this.pulsePhase = 0;
                    this.animating = true;
                    this.dpr = Math.min(window.devicePixelRatio || 1, 3);

                    this.resize();
                    this.animate();
                }

                resize() {
                    const rect = this.canvas.getBoundingClientRect();
                    this.canvas.width = rect.width * this.dpr;
                    this.canvas.height = rect.height * this.dpr;
                    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
                    this.w = rect.width;
                    this.h = rect.height;
                }

                computeVertices(cx, cy, radius, count, rotation) {
                    const verts = [];
                    for (let i = 0; i < count; i++) {
                        const angle =
                            rotation + (i * Math.PI * 2) / count - Math.PI / 2;
                        verts.push({
                            x: cx + radius * Math.cos(angle),
                            y: cy + radius * Math.sin(angle),
                        });
                    }
                    return verts;
                }

                animate() {
                    if (!this.animating) return;
                    this.pulsePhase += 0.015;
                    const pulse = 0.85 + 0.15 * Math.sin(this.pulsePhase);
                    this.opacity = pulse;
                    this.draw();
                    requestAnimationFrame(() => this.animate());
                }

                draw() {
                    const { ctx, w, h, sigil } = this;
                    ctx.clearRect(0, 0, w, h);

                    const cx = w / 2;
                    const cy = h / 2;
                    const radius = (Math.min(w, h) / 2) * 0.85;

                    const outerVerts = this.computeVertices(
                        cx,
                        cy,
                        radius,
                        sigil.vertices,
                        sigil.rotation,
                    );

                    const innerRingVerts = [];
                    for (let ring = 1; ring <= sigil.innerRings; ring++) {
                        const scale = 1.0 - ring * 0.28;
                        const ringRot = sigil.rotation + ring * 0.3;
                        innerRingVerts.push(
                            this.computeVertices(
                                cx,
                                cy,
                                radius * scale,
                                sigil.vertices,
                                ringRot,
                            ),
                        );
                    }

                    // Glow layer
                    if (this.showGlow) {
                        this.drawGlow(cx, cy, radius, outerVerts);
                    }

                    // Edges
                    this.drawEdges(outerVerts, innerRingVerts, cx, cy, radius);

                    // Dots
                    this.drawDots(outerVerts, innerRingVerts, cx, cy);
                }

                drawGlow(cx, cy, radius, outerVerts) {
                    const { ctx, sigil, opacity } = this;

                    // Line glow
                    ctx.save();
                    ctx.strokeStyle = colorToCSS(
                        sigil.primaryColor,
                        0.08 * opacity,
                    );
                    ctx.lineWidth = radius * 0.15;
                    ctx.filter = `blur(${radius * 0.3}px)`;
                    ctx.beginPath();
                    for (let i = 0; i < outerVerts.length; i++) {
                        const next = (i + 1) % outerVerts.length;
                        ctx.moveTo(outerVerts[i].x, outerVerts[i].y);
                        ctx.lineTo(outerVerts[next].x, outerVerts[next].y);
                    }
                    ctx.stroke();

                    // Center glow
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius * 0.15, 0, Math.PI * 2);
                    ctx.fillStyle = colorToCSS(
                        sigil.primaryColor,
                        0.06 * opacity,
                    );
                    ctx.fill();
                    ctx.restore();
                }

                drawEdges(outerVerts, innerRingVerts, cx, cy, radius) {
                    const { ctx, sigil, opacity } = this;
                    const ew = Math.max(0.5, Math.min(3.0, radius * 0.04));

                    // Outer polygon
                    ctx.strokeStyle = colorToCSS(
                        sigil.primaryColor,
                        0.7 * opacity,
                    );
                    ctx.lineWidth = ew;
                    ctx.lineCap = "round";
                    ctx.beginPath();
                    for (let i = 0; i < outerVerts.length; i++) {
                        const next = (i + 1) % outerVerts.length;
                        ctx.moveTo(outerVerts[i].x, outerVerts[i].y);
                        ctx.lineTo(outerVerts[next].x, outerVerts[next].y);
                    }
                    ctx.stroke();

                    // Inner rings
                    ctx.strokeStyle = colorToCSS(
                        sigil.secondaryColor,
                        0.5 * opacity,
                    );
                    ctx.lineWidth = ew * 0.75;
                    for (let ring = 0; ring < innerRingVerts.length; ring++) {
                        const rv = innerRingVerts[ring];
                        const connectTo =
                            ring === 0 ? outerVerts : innerRingVerts[ring - 1];

                        // Ring edges
                        ctx.beginPath();
                        for (let i = 0; i < rv.length; i++) {
                            const next = (i + 1) % rv.length;
                            ctx.moveTo(rv[i].x, rv[i].y);
                            ctx.lineTo(rv[next].x, rv[next].y);
                        }
                        ctx.stroke();

                        // Connections
                        ctx.strokeStyle = colorToCSS(
                            sigil.tertiaryColor,
                            0.35 * opacity,
                        );
                        ctx.lineWidth = ew * 0.5;
                        ctx.beginPath();
                        for (let i = 0; i < rv.length; i++) {
                            ctx.moveTo(connectTo[i].x, connectTo[i].y);
                            ctx.lineTo(rv[i].x, rv[i].y);
                        }
                        ctx.stroke();

                        // Reset for next ring
                        ctx.strokeStyle = colorToCSS(
                            sigil.secondaryColor,
                            0.5 * opacity,
                        );
                        ctx.lineWidth = ew * 0.75;
                    }

                    // Radials
                    if (sigil.drawRadials) {
                        ctx.strokeStyle = colorToCSS(
                            sigil.tertiaryColor,
                            0.35 * opacity,
                        );
                        ctx.lineWidth = ew * 0.5;
                        ctx.beginPath();

                        const innermost =
                            innerRingVerts.length > 0
                                ? innerRingVerts[innerRingVerts.length - 1]
                                : null;

                        if (sigil.centerDot) {
                            const targets = innermost || outerVerts;
                            const skip = Math.max(
                                1,
                                Math.min(
                                    targets.length,
                                    Math.floor(
                                        targets.length / sigil.symmetryFold,
                                    ),
                                ),
                            );
                            for (let i = 0; i < targets.length; i++) {
                                if (i % skip === 0) {
                                    ctx.moveTo(cx, cy);
                                    ctx.lineTo(targets[i].x, targets[i].y);
                                }
                            }
                        } else if (innermost) {
                            for (let i = 0; i < innermost.length; i++) {
                                const target =
                                    (i + sigil.symmetryFold) % innermost.length;
                                if (target !== i) {
                                    ctx.moveTo(innermost[i].x, innermost[i].y);
                                    ctx.lineTo(
                                        innermost[target].x,
                                        innermost[target].y,
                                    );
                                }
                            }
                        } else {
                            for (let i = 0; i < outerVerts.length; i++) {
                                const target =
                                    (i + sigil.symmetryFold) %
                                    outerVerts.length;
                                if (target !== i) {
                                    ctx.moveTo(
                                        outerVerts[i].x,
                                        outerVerts[i].y,
                                    );
                                    ctx.lineTo(
                                        outerVerts[target].x,
                                        outerVerts[target].y,
                                    );
                                }
                            }
                        }
                        ctx.stroke();
                    }
                }

                drawDots(outerVerts, innerRingVerts, cx, cy) {
                    const { ctx, sigil, opacity } = this;
                    const ref = Math.abs(outerVerts[0].x);
                    const dotR = Math.max(1.5, Math.min(5.0, ref * 0.06));

                    // Outer dots
                    ctx.fillStyle = colorToCSS(
                        sigil.primaryColor,
                        0.9 * opacity,
                    );
                    for (const v of outerVerts) {
                        ctx.beginPath();
                        ctx.arc(v.x, v.y, dotR, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Inner dots
                    ctx.fillStyle = colorToCSS(
                        sigil.secondaryColor,
                        0.7 * opacity,
                    );
                    for (const ring of innerRingVerts) {
                        for (const v of ring) {
                            ctx.beginPath();
                            ctx.arc(v.x, v.y, dotR * 0.8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Center dot
                    if (sigil.centerDot) {
                        ctx.fillStyle = colorToCSS(
                            sigil.tertiaryColor,
                            0.8 * opacity,
                        );
                        ctx.beginPath();
                        ctx.arc(cx, cy, dotR * 1.3, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = colorToCSS(
                            sigil.primaryColor,
                            0.3 * opacity,
                        );
                        ctx.beginPath();
                        ctx.arc(cx, cy, dotR * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                destroy() {
                    this.animating = false;
                }
            }

            // =========================================================================
            // Card Background Renderer
            // =========================================================================

            class CardBackgroundRenderer {
                constructor(canvas, sigil, traitColor, rarityColor) {
                    this.canvas = canvas;
                    this.ctx = canvas.getContext("2d");
                    this.sigil = sigil;
                    this.traitColor = traitColor;
                    this.rarityColor = rarityColor;
                    this.dpr = Math.min(window.devicePixelRatio || 1, 3);
                    this.resize();
                    this.draw();
                }

                resize() {
                    const rect = this.canvas.getBoundingClientRect();
                    this.canvas.width = rect.width * this.dpr;
                    this.canvas.height = rect.height * this.dpr;
                    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
                    this.w = rect.width;
                    this.h = rect.height;
                }

                draw() {
                    const { ctx, w, h, sigil, traitColor, rarityColor } = this;
                    ctx.clearRect(0, 0, w, h);

                    // Radial gradient from sigil primary color
                    const g1 = ctx.createRadialGradient(
                        w * 0.5,
                        h * 0.35,
                        0,
                        w * 0.5,
                        h * 0.35,
                        w * 0.7,
                    );
                    g1.addColorStop(0, colorToCSS(sigil.primaryColor, 0.12));
                    g1.addColorStop(
                        0.5,
                        colorToCSS(sigil.secondaryColor, 0.04),
                    );
                    g1.addColorStop(1, "rgba(13,17,23,0)");
                    ctx.fillStyle = g1;
                    ctx.fillRect(0, 0, w, h);

                    // Trait color glow at bottom
                    const g2 = ctx.createRadialGradient(
                        w * 0.5,
                        h * 0.85,
                        0,
                        w * 0.5,
                        h * 0.85,
                        w * 0.5,
                    );
                    g2.addColorStop(0, colorToCSS(traitColor, 0.06));
                    g2.addColorStop(1, "rgba(13,17,23,0)");
                    ctx.fillStyle = g2;
                    ctx.fillRect(0, 0, w, h);

                    // Rarity glow at top
                    const g3 = ctx.createRadialGradient(
                        w * 0.5,
                        0,
                        0,
                        w * 0.5,
                        0,
                        w * 0.4,
                    );
                    g3.addColorStop(0, colorToCSS(rarityColor, 0.05));
                    g3.addColorStop(1, "rgba(13,17,23,0)");
                    ctx.fillStyle = g3;
                    ctx.fillRect(0, 0, w, h);
                }
            }

            // =========================================================================
            // Formatting Helpers
            // =========================================================================

            function formatCompact(value) {
                if (value >= 1000) return (value / 1000).toFixed(1) + "k";
                return "" + value;
            }

            function formatDistance(meters) {
                if (meters == null) return "--";
                if (meters >= 1000) return (meters / 1000).toFixed(1) + "km";
                return Math.round(meters) + "m";
            }

            function formatAge(days) {
                if (days >= 365) return Math.floor(days / 365) + "y";
                if (days > 0) return days + "d";
                return "0d";
            }

            function formatDate(dateStr) {
                if (!dateStr) return "--";
                try {
                    const d = new Date(dateStr);
                    if (isNaN(d.getTime())) return dateStr;
                    const months = [
                        "Jan",
                        "Feb",
                        "Mar",
                        "Apr",
                        "May",
                        "Jun",
                        "Jul",
                        "Aug",
                        "Sep",
                        "Oct",
                        "Nov",
                        "Dec",
                    ];
                    return `${months[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
                } catch {
                    return dateStr;
                }
            }

            // =========================================================================
            // SVG Helpers
            // =========================================================================

            function hexagonSVG(size, color) {
                const r = size / 2;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    points.push(
                        `${r + r * Math.cos(angle)},${r + r * Math.sin(angle)}`,
                    );
                }
                return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
        <polygon points="${points.join(" ")}" fill="none" stroke="${color}" stroke-width="1"/>
      </svg>`;
            }

            // =========================================================================
            // Card Builder
            // =========================================================================

            function buildCard(data) {
                const sigil = generateSigil(data.nodeNum);
                const trait = TRAITS[data.trait] || TRAITS.unknown;
                const rarityKey = computeRarity(
                    data.encounterCount,
                    data.trait,
                );
                const rarity = RARITY_CONFIG[rarityKey];
                const borderColorCSS = colorToCSS(rarity.borderColor);
                const traitColorCSS = colorToCSS(trait.color);

                const stats = [
                    {
                        label: "ENC",
                        value: formatCompact(data.encounterCount),
                        highlight: data.encounterCount >= 20,
                    },
                    {
                        label: "RNG",
                        value: formatDistance(data.maxDistance),
                        highlight:
                            data.maxDistance != null &&
                            data.maxDistance >= 1000,
                    },
                    {
                        label: "MSG",
                        value: formatCompact(data.messageCount),
                        highlight: data.messageCount >= 10,
                    },
                    {
                        label: "SNR",
                        value: data.bestSnr != null ? "" + data.bestSnr : "--",
                        highlight: data.bestSnr != null && data.bestSnr >= 10,
                    },
                    {
                        label: "LNK",
                        value: formatCompact(data.coSeenCount),
                        highlight: data.coSeenCount >= 20,
                    },
                    {
                        label: "AGE",
                        value: formatAge(data.ageDays),
                        highlight: data.ageDays >= 30,
                    },
                ];

                function statColorForIndex(i) {
                    const colors = [
                        sigil.primaryColor,
                        sigil.secondaryColor,
                        sigil.tertiaryColor,
                    ];
                    return colors[i % 3];
                }

                // Device + palette text
                const deviceParts = [];
                if (data.hardwareModel) deviceParts.push(data.hardwareModel);
                if (data.firmwareVersion)
                    deviceParts.push("FW " + data.firmwareVersion);
                const deviceText = deviceParts.join(" \u00B7 ");

                // Discovery date
                const discoveryStr = data.firstSeen
                    ? formatDate(data.firstSeen)
                    : "--";

                // Build DOM
                const root = document.getElementById("app-root");
                root.innerHTML = "";

                // Card wrapper
                const wrapper = document.createElement("div");
                wrapper.className = "card-wrapper";

                // Outer glow (epic/legendary)
                if (rarity.hasGlow) {
                    const glow = document.createElement("div");
                    glow.className = "card-glow";
                    glow.style.boxShadow = `0 0 ${rarity.glowBlur}px ${rarity.glowSpread}px ${colorToCSS(rarity.glowColor, 0.25)}`;
                    glow.style.opacity = "1";
                    wrapper.appendChild(glow);
                }

                const card = document.createElement("div");
                card.className = "card";
                card.style.border = `${rarity.borderWidth}px solid ${borderColorCSS}`;
                if (rarity.hasGlow) {
                    card.style.boxShadow = `0 0 ${rarity.glowBlur}px ${rarity.glowSpread}px ${colorToCSS(rarity.glowColor, 0.35)}, 0 6px 16px rgba(0,0,0,0.5)`;
                } else {
                    card.style.boxShadow = "0 6px 16px rgba(0,0,0,0.5)";
                }

                // Background canvas
                const bgDiv = document.createElement("div");
                bgDiv.className = "card-bg";
                const bgCanvas = document.createElement("canvas");
                bgDiv.appendChild(bgCanvas);
                card.appendChild(bgDiv);

                // Inner highlight
                const highlight = document.createElement("div");
                highlight.className = "card-inner-highlight";
                highlight.style.border = `1px solid ${colorToCSS(rarity.borderColor, 0.08)}`;
                highlight.style.background = `linear-gradient(to bottom, ${colorToCSS(rarity.borderColor, 0.06)}, transparent 15%, transparent 85%, ${colorToCSS(rarity.borderColor, 0.03)})`;
                card.appendChild(highlight);

                // Content
                const content = document.createElement("div");
                content.className = "card-content";

                // -- Trait Banner --
                const banner = document.createElement("div");
                banner.className = "trait-banner";

                const badge = document.createElement("div");
                badge.className = "trait-badge";
                badge.style.background = colorToCSS(trait.color, 0.15);
                badge.style.color = traitColorCSS;
                badge.style.border = `0.5px solid ${colorToCSS(trait.color, 0.25)}`;

                const traitDot = document.createElement("div");
                traitDot.className = "trait-icon";
                traitDot.style.background = traitColorCSS;
                traitDot.style.boxShadow = `0 0 4px ${colorToCSS(trait.color, 0.5)}`;
                badge.appendChild(traitDot);
                badge.appendChild(document.createTextNode(trait.label));
                banner.appendChild(badge);

                if (data.role) {
                    const roleEl = document.createElement("div");
                    roleEl.className = "role-label";
                    roleEl.textContent = data.role.toUpperCase();
                    banner.appendChild(roleEl);
                }

                content.appendChild(banner);

                // -- Sigil Hero --
                const hero = document.createElement("div");
                hero.className = "sigil-hero";

                const canvasWrap = document.createElement("div");
                canvasWrap.className = "sigil-canvas-wrap";

                // Glow behind sigil
                const sigilGlow = document.createElement("div");
                sigilGlow.className = "sigil-glow";
                sigilGlow.style.background = `radial-gradient(circle, ${colorToCSS(sigil.primaryColor, 0.3)}, ${colorToCSS(sigil.secondaryColor, 0.1)}, transparent)`;
                canvasWrap.appendChild(sigilGlow);

                // Orbit ring for rare+
                if (
                    rarityKey === "rare" ||
                    rarityKey === "epic" ||
                    rarityKey === "legendary"
                ) {
                    const orbitRing = document.createElement("div");
                    orbitRing.className = "orbit-ring";
                    // Create a dashed border effect
                    const dashColor = colorToCSS(rarity.borderColor, 0.3);
                    orbitRing.style.border = `1px dashed ${dashColor}`;
                    if (rarityKey === "legendary") {
                        orbitRing.style.borderWidth = "1.5px";
                        orbitRing.style.borderColor = colorToCSS(
                            rarity.borderColor,
                            0.4,
                        );
                        orbitRing.style.boxShadow = `0 0 8px ${colorToCSS(rarity.glowColor, 0.15)}`;
                    }
                    canvasWrap.appendChild(orbitRing);
                }

                const sigilCanvas = document.createElement("canvas");
                sigilCanvas.id = "sigil-canvas";
                canvasWrap.appendChild(sigilCanvas);
                hero.appendChild(canvasWrap);
                content.appendChild(hero);

                // -- Name Plate --
                const namePlate = document.createElement("div");
                namePlate.className = "name-plate";

                const nameEl = document.createElement("div");
                nameEl.className = "node-name";
                nameEl.textContent = data.displayName;
                namePlate.appendChild(nameEl);

                const hexEl = document.createElement("div");
                hexEl.className = "node-hex-id";
                hexEl.style.color = colorToCSS(trait.color, 0.5);
                hexEl.textContent = data.hexId;
                namePlate.appendChild(hexEl);

                content.appendChild(namePlate);

                // -- Ornament Divider --
                const divider = document.createElement("div");
                divider.className = "ornament-divider";

                const leftLine = document.createElement("div");
                leftLine.className = "ornament-line";
                leftLine.style.background = `linear-gradient(to right, transparent, ${borderColorCSS})`;
                divider.appendChild(leftLine);

                const diamond = document.createElement("div");
                diamond.className = "ornament-diamond";
                diamond.style.background = borderColorCSS;
                divider.appendChild(diamond);

                const rightLine = document.createElement("div");
                rightLine.className = "ornament-line";
                rightLine.style.background = `linear-gradient(to left, transparent, ${borderColorCSS})`;
                divider.appendChild(rightLine);

                content.appendChild(divider);

                // -- Stats Grid --
                const statsGrid = document.createElement("div");
                statsGrid.className = "stats-grid";

                for (let row = 0; row < 2; row++) {
                    const rowEl = document.createElement("div");
                    rowEl.className = "stats-row";
                    for (let col = 0; col < 3; col++) {
                        const idx = row * 3 + col;
                        const stat = stats[idx];
                        const cell = document.createElement("div");
                        cell.className =
                            "stat-cell" + (stat.highlight ? " highlight" : "");
                        const statColor = statColorForIndex(idx);

                        const val = document.createElement("div");
                        val.className = "stat-value";
                        val.style.color = colorToCSS(
                            statColor,
                            stat.highlight ? 1.0 : 0.8,
                        );
                        val.textContent = stat.value;
                        cell.appendChild(val);

                        const lbl = document.createElement("div");
                        lbl.className = "stat-label";
                        lbl.textContent = stat.label;
                        cell.appendChild(lbl);

                        rowEl.appendChild(cell);
                    }
                    statsGrid.appendChild(rowEl);
                }
                content.appendChild(statsGrid);

                // -- Device & Palette --
                const devLine = document.createElement("div");
                devLine.className = "device-palette-line";

                const paletteDots = document.createElement("div");
                paletteDots.className = "palette-dots";
                [
                    sigil.primaryColor,
                    sigil.secondaryColor,
                    sigil.tertiaryColor,
                ].forEach((c) => {
                    const dot = document.createElement("div");
                    dot.className = "palette-dot";
                    dot.style.background = colorToCSS(c);
                    dot.style.boxShadow = `0 0 4px ${colorToCSS(c, 0.35)}`;
                    paletteDots.appendChild(dot);
                });
                devLine.appendChild(paletteDots);

                if (deviceText) {
                    const devEl = document.createElement("div");
                    devEl.className = "device-text";
                    devEl.textContent = deviceText;
                    devLine.appendChild(devEl);
                }
                content.appendChild(devLine);

                // -- Brand Footer --
                const footer = document.createElement("div");
                footer.className = "brand-footer";
                footer.style.borderTopColor = colorToCSS(
                    rarity.borderColor,
                    0.15,
                );

                const brand = document.createElement("div");
                brand.className = "brand-mark";
                const hexSvg = document.createElement("span");
                hexSvg.innerHTML = hexagonSVG(9, "rgba(255,255,255,0.25)");
                hexSvg.style.display = "flex";
                brand.appendChild(hexSvg);
                brand.appendChild(document.createTextNode("SOCIALMESH"));
                footer.appendChild(brand);

                const rarityLbl = document.createElement("div");
                rarityLbl.className = "rarity-label";
                rarityLbl.style.color = colorToCSS(rarity.borderColor, 0.7);
                rarityLbl.textContent = rarity.label;
                footer.appendChild(rarityLbl);

                const dateEl = document.createElement("div");
                dateEl.className = "discovery-date";
                dateEl.textContent = discoveryStr;
                footer.appendChild(dateEl);

                content.appendChild(footer);
                card.appendChild(content);
                wrapper.appendChild(card);
                root.appendChild(wrapper);

                // -- App Promo --
                const promo = document.createElement("div");
                promo.className = "app-promo";

                const promoTitle = document.createElement("h2");
                promoTitle.textContent = "Discover nodes on Socialmesh";
                promo.appendChild(promoTitle);

                const promoDesc = document.createElement("p");
                promoDesc.textContent =
                    "The most advanced Meshtastic companion app. Track encounters, collect sigils, and explore the mesh.";
                promo.appendChild(promoDesc);

                const badges = document.createElement("div");
                badges.className = "store-badges";

                const iosLink = document.createElement("a");
                iosLink.href =
                    "https://apps.apple.com/app/socialmesh/id6742694642";
                iosLink.target = "_blank";
                iosLink.rel = "noopener";
                const iosImg = document.createElement("img");
                iosImg.className = "store-badge";
                iosImg.src = "/images/app-store-badge.svg";
                iosImg.alt = "Download on the App Store";
                iosImg.onerror = function () {
                    this.style.display = "none";
                };
                iosLink.appendChild(iosImg);
                badges.appendChild(iosLink);

                const androidLink = document.createElement("a");
                androidLink.href =
                    "https://play.google.com/store/apps/details?id=com.gotnull.socialmesh";
                androidLink.target = "_blank";
                androidLink.rel = "noopener";
                const androidImg = document.createElement("img");
                androidImg.className = "store-badge";
                androidImg.src = "/images/google-play-badge.svg";
                androidImg.alt = "Get it on Google Play";
                androidImg.onerror = function () {
                    this.style.display = "none";
                };
                androidLink.appendChild(androidImg);
                badges.appendChild(androidLink);

                promo.appendChild(badges);
                root.appendChild(promo);

                // Initialize renderers after layout
                requestAnimationFrame(() => {
                    new CardBackgroundRenderer(
                        bgCanvas,
                        sigil,
                        trait.color,
                        rarity.borderColor,
                    );
                    new SigilRenderer(sigilCanvas, sigil, true);
                });

                // Update page title and OG tags
                document.title = `${data.displayName} — Sigil Card — Socialmesh`;
                const ogTitle = document.querySelector(
                    'meta[property="og:title"]',
                );
                if (ogTitle)
                    ogTitle.content = `${data.displayName} — Sigil Card`;
                const ogDesc = document.querySelector(
                    'meta[property="og:description"]',
                );
                if (ogDesc)
                    ogDesc.content = `${trait.label} node with ${data.encounterCount} encounters. ${rarity.label} rarity.`;
            }

            function showError(message) {
                const root = document.getElementById("app-root");
                const errorText =
                    message ||
                    "This sigil card could not be found. It may have been removed or the link may be invalid.";
                root.innerHTML = `
        <div class="error-state">
          <div class="icon">&#x2B21;</div>
          <h2>Sigil Not Found</h2>
          <p>${errorText}</p>
        </div>
        <div class="app-promo" style="margin-top: 32px;">
          <h2>Get Socialmesh</h2>
          <p>The most advanced Meshtastic companion app for iOS and Android.</p>
          <div class="store-badges">
            <a href="https://apps.apple.com/app/socialmesh/id6742694642" target="_blank" rel="noopener">
              <img class="store-badge" src="/images/app-store-badge.svg" alt="Download on the App Store"
                   onerror="this.style.display='none'">
            </a>
            <a href="https://play.google.com/store/apps/details?id=com.gotnull.socialmesh" target="_blank" rel="noopener">
              <img class="store-badge" src="/images/google-play-badge.svg" alt="Get it on Google Play"
                   onerror="this.style.display='none'">
            </a>
          </div>
        </div>
      `;
            }

            // =========================================================================
            // Init
            // =========================================================================

            // Cache the fetched data so resize does not re-fetch
            let cachedData = null;

            document.addEventListener("DOMContentLoaded", async () => {
                const sigilId = extractSigilId();

                if (!sigilId) {
                    showError(
                        "No sigil ID found in this URL. Share a sigil from the Socialmesh app to generate a valid link.",
                    );
                    return;
                }

                // Fetch from API by ID
                cachedData = await fetchSigilData(sigilId);
                if (!cachedData) {
                    showError(
                        "This sigil card could not be loaded. It may have expired or the link may be invalid.",
                    );
                    return;
                }
                buildCard(cachedData);
            });

            // Handle resize — re-render from cached data, no re-fetch
            let resizeTimer;
            window.addEventListener("resize", () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (cachedData) buildCard(cachedData);
                }, 250);
            });
        </script>
    </body>
</html>
