<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mesh Globe</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    /* Hide all Cesium UI */
    .cesium-viewer-bottom,
    .cesium-viewer-toolbar,
    .cesium-viewer-animationContainer,
    .cesium-viewer-timelineContainer,
    .cesium-viewer-fullscreenContainer {
      display: none !important;
    }

    /* Node tooltip */
    .node-tooltip {
      position: absolute;
      background: rgba(10, 10, 20, 0.95);
      border: 1px solid var(--accent, #f97316);
      border-radius: 8px;
      padding: 10px 14px;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      font-size: 13px;
      pointer-events: none;
      z-index: 1000;
      display: none;
      box-shadow: 0 0 20px rgba(249, 115, 22, 0.3);
    }

    .node-tooltip .name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .node-tooltip .coords {
      font-size: 11px;
      color: #888;
      font-family: 'SF Mono', monospace;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <div id="tooltip" class="node-tooltip"></div>

  <script>
    function log(msg) {
      console.log('[CesiumGlobe] ' + msg);
    }

    log('Initializing...');

    // Disable Cesium Ion (we'll use free imagery)
    Cesium.Ion.defaultAccessToken = undefined;

    let viewer;
    try {
      viewer = new Cesium.Viewer('cesiumContainer', {
        // Disable all UI
        baseLayerPicker: false,
        geocoder: false,
        homeButton: false,
        sceneModePicker: false,
        navigationHelpButton: false,
        animation: false,
        timeline: false,
        fullscreenButton: false,
        vrButton: false,
        infoBox: false,
        selectionIndicator: false,
        creditContainer: document.createElement('div'), // Hide credits
        // Use simple imagery - no Ion required
        imageryProvider: new Cesium.OpenStreetMapImageryProvider({
          url: 'https://tile.openstreetmap.org/'
        }),
        // Performance settings
        requestRenderMode: false,
        maximumRenderTimeChange: Infinity,
        targetFrameRate: 60,
        // Disable terrain for cleaner look
        terrainProvider: undefined
      });
      log('Viewer created');
    } catch (e) {
      log('ERROR: ' + e.message);
      console.error(e);
    }

    // Configure scene for dark space look
    const scene = viewer.scene;
    const globe = scene.globe;

    // Black space background
    scene.backgroundColor = Cesium.Color.BLACK;
    scene.skyBox = undefined;
    scene.sun = undefined;
    scene.moon = undefined;
    scene.skyAtmosphere.show = false;

    // Globe settings - NO lighting (causes ugly shadows)
    globe.enableLighting = false;
    globe.showGroundAtmosphere = false;
    globe.baseColor = Cesium.Color.fromCssColorString('#1a1a2e');

    // Disable depth testing for markers (always visible)
    scene.globe.depthTestAgainstTerrain = false;

    // Initial camera position - looking at Earth from space
    viewer.camera.setView({
      destination: Cesium.Cartesian3.fromDegrees(145, -37, 15000000),
      orientation: {
        heading: 0,
        pitch: Cesium.Math.toRadians(-90),
        roll: 0
      }
    });

    log('Scene configured');

    // Data storage
    let nodes = {};
    let connectionEntities = [];
    let accentColor = '#f97316';
    const tooltip = document.getElementById('tooltip');

    // Helper to create position
    function toPosition(lat, lng, altitudeKm = 50) {
      return Cesium.Cartesian3.fromDegrees(lng, lat, altitudeKm * 1000);
    }

    // Create a node marker
    function createNodeMarker(node) {
      const color = Cesium.Color.fromCssColorString(node.avatarColor || accentColor);
      const name = node.shortName || node.longName || '!' + node.nodeNum.toString(16).slice(-4);

      return viewer.entities.add({
        id: 'node_' + node.nodeNum,
        position: toPosition(node.latitude, node.longitude, 10),
        point: {
          pixelSize: 10,
          color: color,
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 2,
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        },
        label: {
          text: name,
          font: 'bold 12px -apple-system, sans-serif',
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 3,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -16),
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          scaleByDistance: new Cesium.NearFarScalar(500000, 1.2, 10000000, 0.4)
        },
        properties: { nodeData: node }
      });
    }

    // Create connection line
    function createConnection(from, to) {
      const color = Cesium.Color.fromCssColorString(accentColor).withAlpha(0.3);

      return viewer.entities.add({
        polyline: {
          positions: [
            toPosition(from.latitude, from.longitude, 5),
            toPosition(to.latitude, to.longitude, 5)
          ],
          width: 1,
          material: color
        }
      });
    }

    // Set all nodes
    function setNodes(nodeList, showConnections = true) {
      log('setNodes: ' + nodeList.length + ' nodes');

      viewer.entities.removeAll();
      nodes = {};
      connectionEntities = [];

      // Add node markers
      nodeList.forEach(n => {
        if (n.latitude && n.longitude) {
          nodes[n.nodeNum] = n;
          createNodeMarker(n);
        }
      });

      // Add connections
      if (showConnections) {
        const arr = Object.values(nodes);
        for (let i = 0; i < arr.length - 1; i++) {
          for (let j = i + 1; j < arr.length; j++) {
            connectionEntities.push(createConnection(arr[i], arr[j]));
          }
        }
        log('Added ' + connectionEntities.length + ' connections');
      }

      // Zoom to nodes if we have any
      if (Object.keys(nodes).length > 0) {
        const firstNode = Object.values(nodes)[0];
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(firstNode.longitude, firstNode.latitude, 2000000),
          duration: 2.0
        });
      }
    }

    function flyTo(lat, lng, height = 2000000, duration = 2.0) {
      log('flyTo: ' + lat + ', ' + lng);
      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),
        duration: duration
      });
    }

    function flyToNode(nodeNum) {
      const node = nodes[nodeNum];
      if (node) {
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(node.longitude, node.latitude, 100000),
          duration: 1.5
        });
      }
    }

    function resetView() {
      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(0, 0, 20000000),
        duration: 1.5
      });
    }

    function setAccentColor(color) {
      log('setAccentColor: ' + color);
      accentColor = color;
      document.documentElement.style.setProperty('--accent', color);
    }

    function setConnectionsVisible(visible) {
      connectionEntities.forEach(e => e.show = visible);
    }

    // Click handler
    const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);

    handler.setInputAction(function (click) {
      const picked = scene.pick(click.position);
      if (Cesium.defined(picked) && picked.id && picked.id.properties) {
        const node = picked.id.properties.nodeData.getValue();
        if (window.flutter_inappwebview) {
          window.flutter_inappwebview.callHandler('onNodeSelected', JSON.stringify(node));
        }
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // Hover tooltip
    handler.setInputAction(function (movement) {
      const picked = scene.pick(movement.endPosition);
      if (Cesium.defined(picked) && picked.id && picked.id.properties) {
        const node = picked.id.properties.nodeData.getValue();
        tooltip.innerHTML = `
          <div class="name">${node.longName || node.shortName || 'Node'}</div>
          <div class="coords">${node.latitude.toFixed(4)}, ${node.longitude.toFixed(4)}</div>
        `;
        tooltip.style.left = (movement.endPosition.x + 15) + 'px';
        tooltip.style.top = (movement.endPosition.y - 10) + 'px';
        tooltip.style.display = 'block';
        document.body.style.cursor = 'pointer';
      } else {
        tooltip.style.display = 'none';
        document.body.style.cursor = 'default';
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    // Notify Flutter
    window.onload = function () {
      log('Ready');
      if (window.flutter_inappwebview) {
        window.flutter_inappwebview.callHandler('onGlobeReady');
      }
    };
  </script>
</body>

</html>