<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mesh Globe</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050510;
      touch-action: manipulation;
    }

    /* Hide all Cesium UI */
    .cesium-viewer-bottom,
    .cesium-viewer-toolbar,
    .cesium-viewer-animationContainer,
    .cesium-viewer-timelineContainer,
    .cesium-viewer-fullscreenContainer,
    .cesium-credit-logoContainer,
    .cesium-credit-textContainer {
      display: none !important;
    }

    /* Node tooltip */
    .node-tooltip {
      position: absolute;
      background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(20, 10, 40, 0.95));
      border: 1px solid var(--accent, #f97316);
      border-radius: 12px;
      padding: 12px 16px;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      font-size: 13px;
      pointer-events: none;
      z-index: 1000;
      display: none;
      box-shadow:
        0 0 30px rgba(249, 115, 22, 0.4),
        0 0 60px rgba(249, 115, 22, 0.2),
        inset 0 0 20px rgba(249, 115, 22, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .node-tooltip .name {
      font-weight: 700;
      font-size: 15px;
      margin-bottom: 6px;
      text-shadow: 0 0 10px var(--accent, #f97316);
    }

    .node-tooltip .coords {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.6);
      font-family: 'SF Mono', 'Menlo', monospace;
    }

    .node-tooltip .status {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
      font-size: 11px;
    }

    .node-tooltip .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
    }

    .node-tooltip .status-dot.online {
      background: #4ade80;
      box-shadow: 0 0 10px #4ade80, 0 0 20px #4ade80;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.7;
        transform: scale(1.2);
      }
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <div id="tooltip" class="node-tooltip"></div>

  <script>
    function log(msg) {
      console.log('[CesiumGlobe] ' + msg);
    }

    log('Initializing epic globe...');

    // Use Cesium Ion for reliable imagery (free tier)
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0MTM2NTQ4Zi0wOTgzLTRhN2ItYjJmOS0xYzViODk0MDMxMjEiLCJpZCI6Mzc3NDI2LCJpYXQiOjE3NjgxODI1NzB9.RSX7GLtIFPbUBT6swRJncmUS5qvwzlnmXQxCh0-969A';

    let viewer;
    try {
      viewer = new Cesium.Viewer('cesiumContainer', {
        baseLayerPicker: false,
        geocoder: false,
        homeButton: false,
        sceneModePicker: false,
        navigationHelpButton: false,
        animation: false,
        timeline: false,
        fullscreenButton: false,
        vrButton: false,
        infoBox: false,
        selectionIndicator: false,
        creditContainer: document.createElement('div'),
        // Use Cesium Ion default imagery (Bing Maps)
        requestRenderMode: false,
        targetFrameRate: 60,
        terrainProvider: undefined,
        shadows: false
      });
      log('Viewer created');
    } catch (e) {
      log('ERROR: ' + e.message);
      console.error(e);
    }

    const scene = viewer.scene;
    const globe = scene.globe;

    // Dark space look
    scene.backgroundColor = Cesium.Color.fromCssColorString('#050510');
    scene.skyBox = undefined;
    scene.sun = undefined;
    scene.moon = undefined;

    // Globe settings - make imagery visible
    globe.enableLighting = false;
    globe.showGroundAtmosphere = false;
    globe.baseColor = Cesium.Color.fromCssColorString('#1a2a3a');
    globe.depthTestAgainstTerrain = false;

    // Disable atmosphere for cleaner look
    if (scene.skyAtmosphere) {
      scene.skyAtmosphere.show = false;
    }

    // Initial camera - Melbourne area
    viewer.camera.setView({
      destination: Cesium.Cartesian3.fromDegrees(145, -37, 8000000),
      orientation: {
        heading: 0,
        pitch: Cesium.Math.toRadians(-80),
        roll: 0
      }
    });

    log('Scene configured');

    // Data storage
    let nodes = {};
    let connectionEntities = [];
    let nodeEntities = [];
    let pulseEntities = [];
    let accentColor = '#f97316';
    let animationFrame = null;
    const tooltip = document.getElementById('tooltip');

    // Animation time
    let animTime = 0;

    // Helper functions
    function toPosition(lat, lng, altitudeKm = 0) {
      return Cesium.Cartesian3.fromDegrees(lng, lat, altitudeKm * 1000);
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16) / 255,
        g: parseInt(result[2], 16) / 255,
        b: parseInt(result[3], 16) / 255
      } : { r: 1, g: 0.5, b: 0 };
    }

    // Create spectacular glowing node marker
    function createNodeMarker(node, index) {
      const baseColor = node.avatarColor || accentColor;
      const rgb = hexToRgb(baseColor);
      const cesiumColor = new Cesium.Color(rgb.r, rgb.g, rgb.b, 1.0);
      const glowColor = new Cesium.Color(rgb.r, rgb.g, rgb.b, 0.6);
      const name = node.shortName || node.longName || '!' + node.nodeNum.toString(16).slice(-4);
      const altitude = 50 + (index % 10) * 10; // Stagger heights

      // Main glowing point - larger for easier tapping
      const mainEntity = viewer.entities.add({
        id: 'node_' + node.nodeNum,
        name: name,
        position: toPosition(node.latitude, node.longitude, altitude),
        point: {
          pixelSize: 16,
          color: cesiumColor,
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 3,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          scaleByDistance: new Cesium.NearFarScalar(100000, 2.5, 15000000, 0.8)
        },
        label: {
          text: name,
          font: 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif',
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 4,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -24),
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          scaleByDistance: new Cesium.NearFarScalar(100000, 1.3, 8000000, 0.5),
          distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 6000000)
        },
        properties: {
          nodeData: node,
          nodeNum: node.nodeNum
        }
      });

      nodeEntities.push(mainEntity);

      // Outer glow ring (pulsing)
      const pulseEntity = viewer.entities.add({
        position: toPosition(node.latitude, node.longitude, altitude),
        ellipse: {
          semiMajorAxis: 20000,
          semiMinorAxis: 20000,
          material: new Cesium.ColorMaterialProperty(glowColor.withAlpha(0.25)),
          outline: true,
          outlineColor: cesiumColor.withAlpha(0.4),
          outlineWidth: 2,
          height: altitude * 1000,
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
      });

      pulseEntities.push({
        entity: pulseEntity,
        baseSize: 20000,
        color: cesiumColor,
        phase: index * 0.5
      });

      // Vertical beam from surface (subtle)
      viewer.entities.add({
        polyline: {
          positions: [
            toPosition(node.latitude, node.longitude, 0),
            toPosition(node.latitude, node.longitude, altitude)
          ],
          width: 2,
          material: new Cesium.PolylineGlowMaterialProperty({
            glowPower: 0.2,
            color: cesiumColor.withAlpha(0.3)
          })
        }
      });

      return mainEntity;
    }

    // Create arcing connection with traveling pulse
    function createArcConnection(from, to, index) {
      const color = hexToRgb(accentColor);
      const cesiumColor = new Cesium.Color(color.r, color.g, color.b, 0.6);

      // Calculate distance for arc height
      const fromCart = Cesium.Cartesian3.fromDegrees(from.longitude, from.latitude, 50000);
      const toCart = Cesium.Cartesian3.fromDegrees(to.longitude, to.latitude, 50000);
      const distance = Cesium.Cartesian3.distance(fromCart, toCart);
      const arcHeight = Math.min(distance * 0.12, 400000);

      // Generate arc points
      const numPoints = 40;
      const positions = [];

      for (let i = 0; i <= numPoints; i++) {
        const t = i / numPoints;
        const lat = from.latitude + (to.latitude - from.latitude) * t;
        const lng = from.longitude + (to.longitude - from.longitude) * t;
        const heightFactor = 4 * t * (1 - t);
        const height = 50000 + arcHeight * heightFactor;
        positions.push(Cesium.Cartesian3.fromDegrees(lng, lat, height));
      }

      // Glowing arc line
      const arcEntity = viewer.entities.add({
        polyline: {
          positions: positions,
          width: 2,
          material: new Cesium.PolylineGlowMaterialProperty({
            glowPower: 0.2,
            color: cesiumColor
          })
        }
      });

      connectionEntities.push(arcEntity);

      // Animated pulse traveling along the arc
      const pulsePoint = viewer.entities.add({
        position: new Cesium.CallbackProperty((time, result) => {
          const t = ((animTime * 0.25 + index * 0.15) % 1);
          const idx = Math.floor(t * (positions.length - 1));
          return positions[Math.min(idx, positions.length - 1)];
        }, false),
        point: {
          pixelSize: 5,
          color: Cesium.Color.WHITE,
          outlineColor: cesiumColor,
          outlineWidth: 2,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          scaleByDistance: new Cesium.NearFarScalar(100000, 1.5, 10000000, 0.3)
        }
      });

      connectionEntities.push(pulsePoint);

      return arcEntity;
    }

    // Animation loop
    function animate() {
      animTime += 0.016;

      // Pulse the glow rings
      pulseEntities.forEach((item) => {
        const pulse = 1 + 0.25 * Math.sin(animTime * 2 + item.phase);
        const newSize = item.baseSize * pulse;
        const alpha = 0.15 + 0.1 * Math.sin(animTime * 2 + item.phase);

        if (item.entity.ellipse) {
          item.entity.ellipse.semiMajorAxis = newSize;
          item.entity.ellipse.semiMinorAxis = newSize;
          item.entity.ellipse.material = new Cesium.ColorMaterialProperty(
            item.color.withAlpha(alpha)
          );
        }
      });

      viewer.scene.requestRender();
      animationFrame = requestAnimationFrame(animate);
    }

    // Set all nodes
    function setNodes(nodeList, showConnections = true) {
      log('setNodes: ' + nodeList.length + ' nodes');

      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }

      viewer.entities.removeAll();
      nodes = {};
      connectionEntities = [];
      nodeEntities = [];
      pulseEntities = [];

      // Add node markers
      let index = 0;
      nodeList.forEach(n => {
        if (n.latitude && n.longitude) {
          nodes[n.nodeNum] = n;
          createNodeMarker(n, index);
          index++;
        }
      });

      // Add arcing connections (limit for performance)
      if (showConnections) {
        const arr = Object.values(nodes);
        let connIndex = 0;
        for (let i = 0; i < arr.length - 1 && connIndex < 80; i++) {
          for (let j = i + 1; j < arr.length && connIndex < 80; j++) {
            createArcConnection(arr[i], arr[j], connIndex);
            connIndex++;
          }
        }
        log('Added ' + connIndex + ' arc connections');
      }

      // Start animation
      animate();

      // Zoom to nodes
      if (Object.keys(nodes).length > 0) {
        const firstNode = Object.values(nodes)[0];
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(firstNode.longitude, firstNode.latitude, 2500000),
          duration: 2.0,
          easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT
        });
      }
    }

    function flyTo(lat, lng, height = 2000000, duration = 2.0) {
      log('flyTo: ' + lat + ', ' + lng);
      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),
        duration: duration,
        easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT
      });
    }

    function flyToNode(nodeNum) {
      const node = nodes[nodeNum];
      if (node) {
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(node.longitude, node.latitude, 150000),
          orientation: {
            heading: Cesium.Math.toRadians(0),
            pitch: Cesium.Math.toRadians(-45),
            roll: 0
          },
          duration: 1.5,
          easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT
        });
      }
    }

    function resetView() {
      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(0, 20, 20000000),
        duration: 2.0,
        easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT
      });
    }

    function setAccentColor(color) {
      log('setAccentColor: ' + color);
      accentColor = color;
      document.documentElement.style.setProperty('--accent', color);
    }

    function setConnectionsVisible(visible) {
      connectionEntities.forEach(e => e.show = visible);
    }

    // ============================================
    // CLICK/TAP HANDLING - Works on mobile!
    // ============================================
    const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);

    function handleNodeTap(position) {
      log('Handling tap at position: ' + JSON.stringify(position));
      const picked = scene.pick(position);
      log('Picked object: ' + (picked ? 'yes' : 'no'));

      if (Cesium.defined(picked)) {
        log('Picked id: ' + (picked.id ? picked.id.id : 'none'));

        // Check if it's one of our node entities
        if (picked.id && picked.id.properties) {
          const props = picked.id.properties;
          if (props.nodeData) {
            const nodeData = props.nodeData.getValue();
            log('Node tapped: ' + JSON.stringify(nodeData));

            if (window.flutter_inappwebview) {
              log('Calling flutter handler onNodeSelected');
              window.flutter_inappwebview.callHandler('onNodeSelected', JSON.stringify(nodeData));
            } else {
              log('ERROR: flutter_inappwebview not available');
            }
            return true;
          }
        }
      }
      return false;
    }

    // Handle both click (desktop) and touch (mobile)
    handler.setInputAction(function (click) {
      log('LEFT_CLICK received');
      handleNodeTap(click.position);
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // Touch-specific: detect tap vs drag
    let touchStartTime = 0;
    let touchStartPosition = null;

    handler.setInputAction(function (event) {
      touchStartTime = Date.now();
      touchStartPosition = event.position;
    }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

    handler.setInputAction(function (event) {
      const duration = Date.now() - touchStartTime;
      const distance = touchStartPosition ?
        Math.sqrt(
          Math.pow(event.position.x - touchStartPosition.x, 2) +
          Math.pow(event.position.y - touchStartPosition.y, 2)
        ) : 0;

      // If it was a quick tap (< 300ms) and didn't move much (< 10px), treat as tap
      if (duration < 300 && distance < 15) {
        log('Quick tap detected, duration=' + duration + 'ms, distance=' + distance + 'px');
        handleNodeTap(event.position);
      }
    }, Cesium.ScreenSpaceEventType.LEFT_UP);

    // Hover tooltip (desktop only - won't fire on mobile)
    handler.setInputAction(function (movement) {
      const picked = scene.pick(movement.endPosition);
      if (Cesium.defined(picked) && picked.id && picked.id.properties && picked.id.properties.nodeData) {
        const node = picked.id.properties.nodeData.getValue();
        tooltip.innerHTML = `
          <div class="name">${node.longName || node.shortName || 'Node'}</div>
          <div class="coords">${node.latitude.toFixed(5)}, ${node.longitude.toFixed(5)}</div>
          <div class="status">
            <span class="status-dot ${node.isOnline ? 'online' : ''}"></span>
            ${node.isOnline ? 'Online' : 'Offline'}
          </div>
        `;
        tooltip.style.left = (movement.endPosition.x + 20) + 'px';
        tooltip.style.top = (movement.endPosition.y - 20) + 'px';
        tooltip.style.display = 'block';
        document.body.style.cursor = 'pointer';
      } else {
        tooltip.style.display = 'none';
        document.body.style.cursor = 'default';
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    // Gentle auto-rotation when idle
    let lastInteraction = Date.now();

    viewer.clock.onTick.addEventListener(() => {
      if (Date.now() - lastInteraction > 8000) {
        viewer.camera.rotate(Cesium.Cartesian3.UNIT_Z, 0.0002);
      }
    });

    handler.setInputAction(() => {
      lastInteraction = Date.now();
    }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

    handler.setInputAction(() => {
      lastInteraction = Date.now();
    }, Cesium.ScreenSpaceEventType.WHEEL);

    // Notify Flutter
    window.onload = function () {
      log('Ready - Epic globe initialized!');
      if (window.flutter_inappwebview) {
        window.flutter_inappwebview.callHandler('onGlobeReady');
      }
    };
  </script>
</body>

</html>