rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =============================================================================
    // HELPER FUNCTIONS
    // =============================================================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    
    // Validate document size (Firestore limit is 1MB, use 500KB for safety)
    function isValidSize() {
      return request.resource.size() < 500 * 1024;
    }
    
    // Owner UID - can use any display name
    function isOwner_displayName() {
      return request.auth.uid == '9ltxJGViWHW5aj5HhLGmiVwkrLU2';
    }
    
    // Reserved exact usernames - blocked for everyone except owner
    function isReservedExactName(displayName) {
      let reserved = [
        'gotnull', 'socialmesh', 'admin', 'administrator', 'support', 'help',
        'info', 'contact', 'official', 'verified', 'mod', 'moderator', 'staff',
        'team', 'root', 'system', 'bot', 'api', 'dev', 'developer', 'meshtastic', 'mesh'
      ];
      return displayName.lower() in reserved;
    }
    
    // Check if display name contains blocked substrings
    // Note: Firestore rules don't support regex, so we use contains() for patterns
    function containsBlockedPattern(displayName) {
      let lowerName = displayName.lower();
      // Block socialmesh variations
      return lowerName.matches('.*socialmesh.*') ||
             lowerName.matches('social.?mesh.*') ||
             // Block gotnull variations
             lowerName.matches('.*gotnull.*') ||
             lowerName.matches('got.?null.*') ||
             // Block admin/mod impersonation
             lowerName.matches('.*admin.*') ||
             lowerName.matches('.*moderator.*') ||
             // Block support impersonation
             lowerName.matches('.*support.*') ||
             // Block official/verified impersonation
             lowerName.matches('.*official.*') ||
             lowerName.matches('.*verified.*') ||
             lowerName.matches('thereal.*') ||
             lowerName.matches('real.*') ||
             // Block meshtastic brand
             lowerName.matches('meshtastic.*');
    }
    
    // Validate display name format
    function isValidDisplayNameFormat(displayName) {
      // Only letters, numbers, periods, underscores (2-30 chars)
      // Cannot start/end with period, no consecutive periods
      return displayName.size() >= 2 &&
             displayName.size() <= 30 &&
             displayName.matches('^[a-zA-Z0-9._]+$') &&
             !displayName.matches('^\\..*') &&
             !displayName.matches('.*\\.$') &&
             !displayName.matches('.*\\.\\..*') &&
             !displayName.matches('^[0-9]+$');
    }
    
    // Main validation function for display names
    function canUseDisplayName(displayName) {
      // Owner can use any name
      return isOwner_displayName() ||
             (isValidDisplayNameFormat(displayName) &&
              !isReservedExactName(displayName) &&
              !containsBlockedPattern(displayName));
    }
    
    // =============================================================================
    // USER DATA COLLECTIONS
    // =============================================================================
    
    // User data - owner read/write (with reserved name enforcement)
    // Admins can write for seeding/testing purposes
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow write: if (isOwner(userId) && 
        (!('displayName' in request.resource.data) || canUseDisplayName(request.resource.data.displayName))) ||
        isAdmin();

      // Activities subcollection - user's activity feed
      match /activities/{activityId} {
        // User can read their own activities
        allow read: if isOwner(userId);
        
        // Activities are created by Cloud Functions or authenticated users
        // (e.g., when someone likes your story, they create an activity in your feed)
        allow create: if isAuthenticated();
        
        // User can update their own activities (mark as read)
        allow update: if isOwner(userId);
        
        // User can delete their own activities
        allow delete: if isOwner(userId);
      }
    }
    
    // User presence - public read, owner write
    // Tracks online/offline status for social features
    match /presence/{userId} {
      allow read: if true;
      allow write: if isOwner(userId);
    }
    
    // User profiles - public read, owner write (except counters)
    // Admins can write for testing/seeding purposes (full access)
    match /profiles/{userId} {
      allow read: if true;
      // Owner can write but cannot modify counter fields (Cloud Functions only)
      // Also enforce reserved display name restrictions
      // Admins can create any profile for seeding test users (bypass all validation)
      allow create: if isAdmin() || (isOwner(userId) && isValidSize() &&
        (!('followerCount' in request.resource.data) || request.resource.data.followerCount == 0) &&
        (!('followingCount' in request.resource.data) || request.resource.data.followingCount == 0) &&
        (!('postCount' in request.resource.data) || request.resource.data.postCount == 0) &&
        (!('displayName' in request.resource.data) || canUseDisplayName(request.resource.data.displayName)));
      // Allow owner to update non-counter fields, OR allow counter increments only
      // Also enforce reserved display name restrictions on updates
      // Admins can update any profile for testing purposes (bypass all validation)
      allow update: if isAdmin() || (isOwner(userId) && isValidSize() &&
        (!('displayName' in request.resource.data) || canUseDisplayName(request.resource.data.displayName)) &&
        (
          // Option 1: Non-counter field updates (displayName, bio, avatarUrl, etc.)
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['followerCount', 'followingCount', 'postCount']))
          ||
          // Option 2: Counter-only updates (for post create/delete, follow/unfollow)
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['postCount', 'followerCount', 'followingCount']))
        ));
      // Admins can delete test profiles
      allow delete: if isOwner(userId) || isAdmin();
    }
    
    // Admin list - only readable by admins
    match /admins/{adminId} {
      allow read: if isAdmin() || isOwner(adminId);
      allow write: if false; // Managed via Firebase Console
    }
    
    // =============================================================================
    // APP CONFIG & WIDGETS
    // =============================================================================
    
    // App config - public read, admin write
    match /app_config/{configId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // Widgets marketplace - public read, authenticated write
    match /widgets/{widgetId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidSize();
      allow update: if isAuthenticated() && isValidSize() &&
        (resource.data.authorId == request.auth.uid || isAdmin());
      allow delete: if isAuthenticated() && 
        (resource.data.authorId == request.auth.uid || isAdmin());
      
      // Widget ratings subcollection
      match /ratings/{ratingId} {
        allow read: if true;
        allow write: if isAuthenticated() && ratingId == request.auth.uid;
      }
    }
    
    // Categories - public read, admin write
    match /categories/{categoryId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // =============================================================================
    // SHARING & SOCIAL
    // =============================================================================
    
    // Shared nodes (for share links)
    match /shared_nodes/{nodeId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidSize();
      allow update, delete: if isAuthenticated() && 
        resource.data.createdBy == request.auth.uid;
    }
    
    // =============================================================================
    // DEVICE SHOP COLLECTIONS
    // =============================================================================
    
    // Shop Products - public read, admin write, authenticated users can increment viewCount
    match /shopProducts/{productId} {
      allow read: if true;
      allow create: if isAdmin();
      allow delete: if isAdmin();
      // Allow admins full update, or authenticated users to only update viewCount
      allow update: if isAdmin() || 
        (isAuthenticated() && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount']) &&
         request.resource.data.viewCount == resource.data.viewCount + 1);
    }
    
    // Shop Sellers - public read, admin write
    match /shopSellers/{sellerId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // Product Reviews - public read, authenticated create, owner/admin manage
    match /productReviews/{reviewId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidSize() &&
        request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && isValidSize() &&
        (resource.data.userId == request.auth.uid || isAdmin());
      allow delete: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || isAdmin());
    }
    
    // Product Favorites - owner only
    match /productFavorites/{favoriteId} {
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Shop Analytics - admin only
    match /shopAnalytics/{docId} {
      allow read, write: if isAdmin();
    }

    // =============================================================================
    // CLOUD SYNC / SUBSCRIPTION COLLECTIONS
    // =============================================================================
    
    // User entitlements - owner read, write via Cloud Functions only
    match /user_entitlements/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Managed by Cloud Functions (RevenueCat webhook)
    }
    
    // Helper function to check cloud sync entitlement
    function hasCloudSyncAccess(userId) {
      let entitlement = get(/databases/$(database)/documents/user_entitlements/$(userId));
      return entitlement != null && 
        (entitlement.data.cloud_sync == 'active' || 
         entitlement.data.cloud_sync == 'grace_period' ||
         entitlement.data.cloud_sync == 'grandfathered');
    }
    
    function hasCloudSyncReadAccess(userId) {
      let entitlement = get(/databases/$(database)/documents/user_entitlements/$(userId));
      return entitlement != null && entitlement.data.cloud_sync != null;
    }
    
    // Synced nodes - cloud sync required for write, read-only for expired
    match /synced_nodes/{userId}/{document=**} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Synced messages - cloud sync required for write, read-only for expired  
    match /synced_messages/{userId}/{document=**} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Synced channels - cloud sync required for write, read-only for expired
    match /synced_channels/{userId}/{document=**} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Synced settings - cloud sync required for write, read-only for expired
    match /synced_settings/{userId} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Sync data (generic sync collection used by Cloud Functions)
    match /sync_data/{userId}/{collection}/{docId} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
      
      // Rate limit tracking (managed by Cloud Functions)
      match /_rate_limit/{limitId} {
        allow read, write: if false; // Cloud Functions only
      }
    }

    // =============================================================================
    // SOCIAL FEATURES (follows, posts, feeds, comments)
    // =============================================================================

    // Follow relationships
    // Document ID format: {followerId}_{followeeId} for idempotent operations
    match /follows/{followId} {
      allow read: if true; // Public - anyone can see follow relationships
      
      // Create: authenticated, valid ID format, cannot self-follow
      // Either: 1) following as yourself (direct follow)
      //     or: 2) you're the followee accepting a follow request
      allow create: if isAuthenticated() &&
        request.resource.data.followerId != request.resource.data.followeeId &&
        followId == request.resource.data.followerId + '_' + request.resource.data.followeeId &&
        (request.resource.data.followerId == request.auth.uid ||
         request.resource.data.followeeId == request.auth.uid);
      
      // Delete: only the follower can unfollow (or admin for testing)
      allow delete: if isAdmin() || (isAuthenticated() &&
        resource.data.followerId == request.auth.uid);
      
      // No updates allowed - delete and recreate
      allow update: if false;
    }

    // Follow requests - for private accounts (approval required)
    // Document ID format: {requesterId}_{targetId} for idempotent operations
    match /follow_requests/{requestId} {
      // Admins can read all requests (for testing/moderation)
      // Users can read requests they sent or received
      // Also allow read if document doesn't exist (to check existence)
      allow read: if isAdmin() || 
        (isAuthenticated() &&
         (resource == null ||
          resource.data.requesterId == request.auth.uid ||
          resource.data.targetId == request.auth.uid));
      
      // Create: authenticated, must be requesting as yourself, cannot self-request
      // Admins can create on behalf of others (for seeding/testing)
      allow create: if isAdmin() ||
        (isAuthenticated() &&
         request.resource.data.requesterId == request.auth.uid &&
         request.resource.data.requesterId != request.resource.data.targetId &&
         request.resource.data.status == 'pending' &&
         requestId == request.resource.data.requesterId + '_' + request.resource.data.targetId);
      
      // Update: only target can update status (approve/decline), or admin
      allow update: if isAdmin() ||
        (isAuthenticated() &&
         resource.data.targetId == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt']));
      
      // Delete: requester can cancel, target can delete after responding, or admin
      allow delete: if isAdmin() ||
        (isAuthenticated() &&
         (resource.data.requesterId == request.auth.uid ||
          resource.data.targetId == request.auth.uid));
    }

    // Posts - user-created content
    // Admins can create/delete for testing purposes
    match /posts/{postId} {
      allow read: if true; // Public posts
      
      // Create: authenticated, must be author, content required
      // Signals must have expiresAt and valid TTL
      // Admins can create posts for seeding test data
      allow create: if isAdmin() || (isAuthenticated() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 2000 &&
        // Signal-specific validation
        (request.resource.data.postMode != 'signal' || (
          request.resource.data.expiresAt is timestamp &&
          request.resource.data.expiresAt.toMillis() > request.time.toMillis() &&
          request.resource.data.expiresAt.toMillis() <= request.time.toMillis() + (86400 * 1000) // max 24h TTL
        )) &&
        isValidSize());
      
      // Delete: only author can delete their post (or admin)
      allow delete: if isAdmin() || (isAuthenticated() &&
        resource.data.authorId == request.auth.uid);
      
      // Update rules:
      // 1. Anyone authenticated can update commentCount/likeCount (social interactions)
      // 2. Author can update image fields (mediaUrls, imageState, imageUrl) for upload after creation
      allow update: if isAuthenticated() &&
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentCount', 'likeCount']) ||
         (resource.data.authorId == request.auth.uid &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['mediaUrls', 'imageState', 'imageUrl'])));
      
      // Signal comments subcollection (canonical path)
      match /comments/{commentId} {
        allow read: if true; // Public comments on signals
        
        // Create: authenticated, must be author, valid content
        allow create: if isAuthenticated() &&
          request.resource.data.authorId == request.auth.uid &&
          request.resource.data.signalId == postId &&
          request.resource.data.content is string &&
          request.resource.data.content.size() > 0 &&
          request.resource.data.content.size() <= 500;
        
        // Delete: only author (or admin)
        allow delete: if isAdmin() || (isAuthenticated() &&
          resource.data.authorId == request.auth.uid);
        
        // No updates allowed - comments are immutable
        allow update: if false;
      }
    }

    // Signal Responses - ephemeral replies to mesh signals
    // Responses are gated by having the signal locally (mesh receipt)
    // Structure: responses/{signalId}/items/{responseId}
    match /responses/{signalId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated(); // Allow creating container doc
      
      match /items/{responseId} {
        // Read: any authenticated user (gating is done client-side by signal presence)
        allow read: if isAuthenticated();
        
        // Create: authenticated, must be author, valid content
        allow create: if isAuthenticated() &&
          request.resource.data.authorId == request.auth.uid &&
          request.resource.data.content is string &&
          request.resource.data.content.size() > 0 &&
          request.resource.data.content.size() <= 500 &&
          request.resource.data.signalId == signalId &&
          request.resource.data.expiresAt is timestamp;
        
        // Delete: only author can delete (or admin)
        allow delete: if isAdmin() || (isAuthenticated() &&
          resource.data.authorId == request.auth.uid);
        
        // No updates allowed - responses are immutable
        allow update: if false;
      }
    }

    // Feeds - precomputed personalized feeds (Cloud Functions write only)
    match /feeds/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Cloud Functions only
      
      // Feed items subcollection
      match /items/{itemId} {
        allow read: if isOwner(userId);
        allow write: if false; // Cloud Functions only
      }
    }

    // Comments - threaded comments on posts
    // Admins can create/delete for testing purposes
    match /comments/{commentId} {
      allow read: if true; // Public comments
      
      // Create: authenticated, must be author, content required, max depth check
      // Admins can create comments for seeding test data
      allow create: if isAdmin() || (isAuthenticated() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 1000 &&
        request.resource.data.postId is string &&
        isValidSize());
      
      // Delete: only author can delete their comment (or admin)
      allow delete: if isAdmin() || (isAuthenticated() &&
        resource.data.authorId == request.auth.uid);
      
      // Allow authenticated users to update only replyCount
      allow update: if isAuthenticated() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['replyCount']);
    }

    // Likes - user likes on posts and comments
    // Document ID formats: 
    //   Posts: {userId}_{postId}
    //   Comments: {userId}_comment_{commentId}
    match /likes/{likeId} {
      allow read: if true; // Public likes
      
      // Create: authenticated, must be liking as yourself
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        (
          // Legacy post likes: {userId}_{postId} with postId field
          ('postId' in request.resource.data && 
           likeId == request.resource.data.userId + '_' + request.resource.data.postId) ||
          // New post likes: {userId}_{postId} with targetType/targetId
          (request.resource.data.targetType == 'post' && 
           likeId == request.resource.data.userId + '_' + request.resource.data.targetId) ||
          // Comment likes: {userId}_comment_{commentId}
          (request.resource.data.targetType == 'comment' && 
           likeId == request.resource.data.userId + '_comment_' + request.resource.data.targetId)
        );
      
      // Delete: only the liker can unlike
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
      
      // No updates allowed
      allow update: if false;
    }

    // Block list - users can block other users
    match /blocks/{blockId} {
      // Only the blocker can read their own blocks
      allow read: if isAuthenticated() &&
        resource.data.blockerId == request.auth.uid;
      
      // Create: authenticated, must be blocking as yourself, cannot self-block
      allow create: if isAuthenticated() &&
        request.resource.data.blockerId == request.auth.uid &&
        request.resource.data.blockerId != request.resource.data.blockedId &&
        blockId == request.resource.data.blockerId + '_' + request.resource.data.blockedId;
      
      // Delete: only the blocker can unblock
      allow delete: if isAuthenticated() &&
        resource.data.blockerId == request.auth.uid;
      
      allow update: if false;
    }

    // Reports - users can report content
    match /reports/{reportId} {
      // Admins can read all reports
      allow read: if isAdmin();
      
      // Any authenticated user can create a report
      allow create: if isAuthenticated() &&
        request.resource.data.reporterId == request.auth.uid &&
        request.resource.data.status == 'pending';
      
      // Only admins can update (resolve) reports
      allow update: if isAdmin();
      
      // Only admins can delete reports
      allow delete: if isAdmin();
    }

    // =============================================================================
    // CONTENT MODERATION SYSTEM
    // =============================================================================

    // Moderation results - AI scan results (Cloud Functions write, admin read)
    match /content_moderation/{docId} {
      allow read: if isAdmin();
      allow write: if false; // Cloud Functions only
    }

    // Moderation queue - items pending human review (Cloud Functions write, admin read/update)
    match /moderation_queue/{itemId} {
      allow read: if isAdmin();
      allow create: if false; // Cloud Functions only
      allow update: if isAdmin(); // Admin reviews
      allow delete: if isAdmin();
    }

    // Moderation checks - text content checks log (Cloud Functions only)
    match /moderation_checks/{checkId} {
      allow read: if isAdmin();
      allow write: if false; // Cloud Functions only
    }

    // User strikes - violations tracking
    match /user_strikes/{strikeId} {
      // Users can read their own strikes, admins can read all
      allow read: if isAdmin() || 
        (isAuthenticated() && resource.data.userId == request.auth.uid);
      // Cloud Functions create strikes
      allow create: if false;
      // Users can acknowledge their strikes
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['acknowledged', 'acknowledgedAt']);
      // Only admins can delete strikes
      allow delete: if isAdmin();
    }

    // Admin logs - audit trail (Cloud Functions write, admin read)
    match /adminLogs/{logId} {
      allow read: if isAdmin();
      allow write: if false; // Cloud Functions only
    }

    // Email queue - for ban notifications (Cloud Functions only)
    match /mail/{mailId} {
      allow read, write: if false; // Cloud Functions / Firebase Extensions only
    }

    // =============================================================================
    // STORIES (ephemeral content)
    // =============================================================================

    // Stories - ephemeral content that expires after 24 hours
    match /stories/{storyId} {
      // Public stories are visible to everyone
      // Private stories require follower relationship check
      allow read: if true; // Visibility filtering done in app queries
      
      // Create: authenticated, must be author (or admin for seeding)
      allow create: if isAuthenticated() &&
        (request.resource.data.authorId == request.auth.uid || isAdmin()) &&
        request.resource.data.mediaUrl is string &&
        request.resource.data.mediaUrl.size() > 0 &&
        isValidSize();
      
      // Delete: only author can delete their story (or admin)
      allow delete: if isAdmin() || (isAuthenticated() &&
        resource.data.authorId == request.auth.uid);
      
      // Update: view count and like count updates allowed by authenticated users
      allow update: if isAuthenticated() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount', 'likeCount']);

      // Story viewers subcollection - tracks who viewed the story
      match /viewers/{viewerId} {
        // Story author can see ALL viewers
        // Users can read their OWN view record to check if they viewed
        allow read: if isAuthenticated() &&
          (get(/databases/$(database)/documents/stories/$(storyId)).data.authorId == request.auth.uid ||
           viewerId == request.auth.uid);
        
        // Author can delete viewers (when deleting story)
        allow delete: if isAuthenticated() &&
          get(/databases/$(database)/documents/stories/$(storyId)).data.authorId == request.auth.uid;
        
        // Any authenticated user can record their view (as themselves)
        allow create: if isAuthenticated() &&
          viewerId == request.auth.uid;
        
        // No updates
        allow update: if false;
      }

      // Story likes subcollection - tracks who liked the story
      match /likes/{likerId} {
        // Story author can see ALL likes
        // Users can read their OWN like record to check if they liked
        allow read: if isAuthenticated() &&
          (get(/databases/$(database)/documents/stories/$(storyId)).data.authorId == request.auth.uid ||
           likerId == request.auth.uid);
        
        // Any authenticated user can like (as themselves)
        allow create: if isAuthenticated() &&
          likerId == request.auth.uid;
        
        // Users can unlike their own likes
        allow delete: if isAuthenticated() &&
          likerId == request.auth.uid;
        
        // No updates
        allow update: if false;
      }
    }
  }
}
