rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =============================================================================
    // HELPER FUNCTIONS
    // =============================================================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }
    
    // Validate document size (Firestore limit is 1MB, use 500KB for safety)
    function isValidSize() {
      return request.resource.size() < 500 * 1024;
    }
    
    // Owner UID - can use any display name
    function isOwner_displayName() {
      return request.auth.uid == 'rAHv8sx4UeTajyeBurx9ZjjBzWn1';
    }
    
    // Reserved exact usernames - blocked for everyone except owner
    function isReservedExactName(displayName) {
      let reserved = [
        'gotnull', 'socialmesh', 'admin', 'administrator', 'support', 'help',
        'info', 'contact', 'official', 'verified', 'mod', 'moderator', 'staff',
        'team', 'root', 'system', 'bot', 'api', 'dev', 'developer', 'meshtastic', 'mesh'
      ];
      return displayName.lower() in reserved;
    }
    
    // Check if display name contains blocked substrings
    // Note: Firestore rules don't support regex, so we use contains() for patterns
    function containsBlockedPattern(displayName) {
      let lowerName = displayName.lower();
      // Block socialmesh variations
      return lowerName.matches('.*socialmesh.*') ||
             lowerName.matches('social.?mesh.*') ||
             // Block gotnull variations
             lowerName.matches('.*gotnull.*') ||
             lowerName.matches('got.?null.*') ||
             // Block admin/mod impersonation
             lowerName.matches('.*admin.*') ||
             lowerName.matches('.*moderator.*') ||
             // Block support impersonation
             lowerName.matches('.*support.*') ||
             // Block official/verified impersonation
             lowerName.matches('.*official.*') ||
             lowerName.matches('.*verified.*') ||
             lowerName.matches('thereal.*') ||
             lowerName.matches('real.*') ||
             // Block meshtastic brand
             lowerName.matches('meshtastic.*');
    }
    
    // Validate display name format
    function isValidDisplayNameFormat(displayName) {
      // Only letters, numbers, periods, underscores (2-30 chars)
      // Cannot start/end with period, no consecutive periods
      return displayName.size() >= 2 &&
             displayName.size() <= 30 &&
             displayName.matches('^[a-zA-Z0-9._]+$') &&
             !displayName.matches('^\\..*') &&
             !displayName.matches('.*\\.$') &&
             !displayName.matches('.*\\.\\..*') &&
             !displayName.matches('^[0-9]+$');
    }
    
    // Main validation function for display names
    function canUseDisplayName(displayName) {
      // Owner can use any name
      return isOwner_displayName() ||
             (isValidDisplayNameFormat(displayName) &&
              !isReservedExactName(displayName) &&
              !containsBlockedPattern(displayName));
    }
    
    // =============================================================================
    // USER DATA COLLECTIONS
    // =============================================================================
    
    // User data - owner read/write (with reserved name enforcement)
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId) && 
        (!('displayName' in request.resource.data) || canUseDisplayName(request.resource.data.displayName));
    }
    
    // User presence - public read, owner write
    // Tracks online/offline status for social features
    match /presence/{userId} {
      allow read: if true;
      allow write: if isOwner(userId);
    }
    
    // User profiles - public read, owner write (except counters)
    match /profiles/{userId} {
      allow read: if true;
      // Owner can write but cannot modify counter fields (Cloud Functions only)
      // Also enforce reserved display name restrictions
      allow create: if isOwner(userId) && isValidSize() &&
        (!('followerCount' in request.resource.data) || request.resource.data.followerCount == 0) &&
        (!('followingCount' in request.resource.data) || request.resource.data.followingCount == 0) &&
        (!('postCount' in request.resource.data) || request.resource.data.postCount == 0) &&
        (!('displayName' in request.resource.data) || canUseDisplayName(request.resource.data.displayName));
      // Allow owner to update non-counter fields, OR allow counter increments only
      // Also enforce reserved display name restrictions on updates
      allow update: if isOwner(userId) && isValidSize() &&
        (!('displayName' in request.resource.data) || canUseDisplayName(request.resource.data.displayName)) &&
        (
          // Option 1: Non-counter field updates (displayName, bio, avatarUrl, etc.)
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['followerCount', 'followingCount', 'postCount']))
          ||
          // Option 2: Counter-only updates (for post create/delete, follow/unfollow)
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['postCount', 'followerCount', 'followingCount']))
        );
      allow delete: if isOwner(userId);
    }
    
    // Admin list - only readable by admins
    match /admins/{adminId} {
      allow read: if isAdmin() || isOwner(adminId);
      allow write: if false; // Managed via Firebase Console
    }
    
    // =============================================================================
    // APP CONFIG & WIDGETS
    // =============================================================================
    
    // App config - public read, admin write
    match /app_config/{configId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // Widgets marketplace - public read, authenticated write
    match /widgets/{widgetId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidSize();
      allow update: if isAuthenticated() && isValidSize() &&
        (resource.data.authorId == request.auth.uid || isAdmin());
      allow delete: if isAuthenticated() && 
        (resource.data.authorId == request.auth.uid || isAdmin());
      
      // Widget ratings subcollection
      match /ratings/{ratingId} {
        allow read: if true;
        allow write: if isAuthenticated() && ratingId == request.auth.uid;
      }
    }
    
    // Categories - public read, admin write
    match /categories/{categoryId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // =============================================================================
    // SHARING & SOCIAL
    // =============================================================================
    
    // Shared nodes (for share links)
    match /shared_nodes/{nodeId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidSize();
      allow update, delete: if isAuthenticated() && 
        resource.data.createdBy == request.auth.uid;
    }
    
    // =============================================================================
    // DEVICE SHOP COLLECTIONS
    // =============================================================================
    
    // Shop Products - public read, admin write, authenticated users can increment viewCount
    match /shopProducts/{productId} {
      allow read: if true;
      allow create: if isAdmin();
      allow delete: if isAdmin();
      // Allow admins full update, or authenticated users to only update viewCount
      allow update: if isAdmin() || 
        (isAuthenticated() && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount']) &&
         request.resource.data.viewCount == resource.data.viewCount + 1);
    }
    
    // Shop Sellers - public read, admin write
    match /shopSellers/{sellerId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // Product Reviews - public read, authenticated create, owner/admin manage
    match /productReviews/{reviewId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidSize() &&
        request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && isValidSize() &&
        (resource.data.userId == request.auth.uid || isAdmin());
      allow delete: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || isAdmin());
    }
    
    // Product Favorites - owner only
    match /productFavorites/{favoriteId} {
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Shop Analytics - admin only
    match /shopAnalytics/{docId} {
      allow read, write: if isAdmin();
    }

    // =============================================================================
    // CLOUD SYNC / SUBSCRIPTION COLLECTIONS
    // =============================================================================
    
    // User entitlements - owner read, write via Cloud Functions only
    match /user_entitlements/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Managed by Cloud Functions (RevenueCat webhook)
    }
    
    // Helper function to check cloud sync entitlement
    function hasCloudSyncAccess(userId) {
      let entitlement = get(/databases/$(database)/documents/user_entitlements/$(userId));
      return entitlement != null && 
        (entitlement.data.cloud_sync == 'active' || 
         entitlement.data.cloud_sync == 'grace_period' ||
         entitlement.data.cloud_sync == 'grandfathered');
    }
    
    function hasCloudSyncReadAccess(userId) {
      let entitlement = get(/databases/$(database)/documents/user_entitlements/$(userId));
      return entitlement != null && entitlement.data.cloud_sync != null;
    }
    
    // Synced nodes - cloud sync required for write, read-only for expired
    match /synced_nodes/{userId}/{document=**} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Synced messages - cloud sync required for write, read-only for expired  
    match /synced_messages/{userId}/{document=**} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Synced channels - cloud sync required for write, read-only for expired
    match /synced_channels/{userId}/{document=**} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Synced settings - cloud sync required for write, read-only for expired
    match /synced_settings/{userId} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
    }
    
    // Sync data (generic sync collection used by Cloud Functions)
    match /sync_data/{userId}/{collection}/{docId} {
      allow read: if isOwner(userId) && hasCloudSyncReadAccess(userId);
      allow write: if isOwner(userId) && hasCloudSyncAccess(userId) && isValidSize();
      
      // Rate limit tracking (managed by Cloud Functions)
      match /_rate_limit/{limitId} {
        allow read, write: if false; // Cloud Functions only
      }
    }

    // =============================================================================
    // SOCIAL FEATURES (follows, posts, feeds, comments)
    // =============================================================================

    // Follow relationships
    // Document ID format: {followerId}_{followeeId} for idempotent operations
    match /follows/{followId} {
      allow read: if true; // Public - anyone can see follow relationships
      
      // Create: authenticated, must be following as yourself, cannot self-follow
      allow create: if isAuthenticated() &&
        request.resource.data.followerId == request.auth.uid &&
        request.resource.data.followerId != request.resource.data.followeeId &&
        followId == request.resource.data.followerId + '_' + request.resource.data.followeeId;
      
      // Delete: only the follower can unfollow
      allow delete: if isAuthenticated() &&
        resource.data.followerId == request.auth.uid;
      
      // No updates allowed - delete and recreate
      allow update: if false;
    }

    // Follow requests - for private accounts (Instagram-style approval)
    // Document ID format: {requesterId}_{targetId} for idempotent operations
    match /follow_requests/{requestId} {
      // Users can read requests they sent or received
      allow read: if isAuthenticated() &&
        (resource.data.requesterId == request.auth.uid ||
         resource.data.targetId == request.auth.uid);
      
      // Create: authenticated, must be requesting as yourself, cannot self-request
      allow create: if isAuthenticated() &&
        request.resource.data.requesterId == request.auth.uid &&
        request.resource.data.requesterId != request.resource.data.targetId &&
        request.resource.data.status == 'pending' &&
        requestId == request.resource.data.requesterId + '_' + request.resource.data.targetId;
      
      // Update: only target can update status (approve/decline)
      allow update: if isAuthenticated() &&
        resource.data.targetId == request.auth.uid &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt']);
      
      // Delete: requester can cancel, target can delete after responding
      allow delete: if isAuthenticated() &&
        (resource.data.requesterId == request.auth.uid ||
         resource.data.targetId == request.auth.uid);
    }

    // Posts - user-created content
    match /posts/{postId} {
      allow read: if true; // Public posts
      
      // Create: authenticated, must be author, content required
      allow create: if isAuthenticated() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 2000 &&
        isValidSize();
      
      // Delete: only author can delete their post
      allow delete: if isAuthenticated() &&
        resource.data.authorId == request.auth.uid;
      
      // Allow authenticated users to update only commentCount and likeCount
      allow update: if isAuthenticated() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentCount', 'likeCount']);
    }

    // Feeds - precomputed personalized feeds (Cloud Functions write only)
    match /feeds/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Cloud Functions only
      
      // Feed items subcollection
      match /items/{itemId} {
        allow read: if isOwner(userId);
        allow write: if false; // Cloud Functions only
      }
    }

    // Comments - threaded comments on posts
    match /comments/{commentId} {
      allow read: if true; // Public comments
      
      // Create: authenticated, must be author, content required, max depth check
      allow create: if isAuthenticated() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 1000 &&
        request.resource.data.postId is string &&
        isValidSize();
      
      // Delete: only author can delete their comment
      allow delete: if isAuthenticated() &&
        resource.data.authorId == request.auth.uid;
      
      // Allow authenticated users to update only replyCount
      allow update: if isAuthenticated() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['replyCount']);
    }

    // Likes - user likes on posts and comments
    // Document ID formats: 
    //   Posts: {userId}_{postId}
    //   Comments: {userId}_comment_{commentId}
    match /likes/{likeId} {
      allow read: if true; // Public likes
      
      // Create: authenticated, must be liking as yourself
      allow create: if isAuthenticated() &&
        request.resource.data.userId == request.auth.uid &&
        (
          // Legacy post likes: {userId}_{postId} with postId field
          ('postId' in request.resource.data && 
           likeId == request.resource.data.userId + '_' + request.resource.data.postId) ||
          // New post likes: {userId}_{postId} with targetType/targetId
          (request.resource.data.targetType == 'post' && 
           likeId == request.resource.data.userId + '_' + request.resource.data.targetId) ||
          // Comment likes: {userId}_comment_{commentId}
          (request.resource.data.targetType == 'comment' && 
           likeId == request.resource.data.userId + '_comment_' + request.resource.data.targetId)
        );
      
      // Delete: only the liker can unlike
      allow delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
      
      // No updates allowed
      allow update: if false;
    }

    // Block list - users can block other users
    match /blocks/{blockId} {
      // Only the blocker can read their own blocks
      allow read: if isAuthenticated() &&
        resource.data.blockerId == request.auth.uid;
      
      // Create: authenticated, must be blocking as yourself, cannot self-block
      allow create: if isAuthenticated() &&
        request.resource.data.blockerId == request.auth.uid &&
        request.resource.data.blockerId != request.resource.data.blockedId &&
        blockId == request.resource.data.blockerId + '_' + request.resource.data.blockedId;
      
      // Delete: only the blocker can unblock
      allow delete: if isAuthenticated() &&
        resource.data.blockerId == request.auth.uid;
      
      allow update: if false;
    }

    // Reports - users can report content
    match /reports/{reportId} {
      // Admins can read all reports
      allow read: if isAdmin();
      
      // Any authenticated user can create a report
      allow create: if isAuthenticated() &&
        request.resource.data.reporterId == request.auth.uid &&
        request.resource.data.status == 'pending';
      
      // Only admins can update (resolve) reports
      allow update: if isAdmin();
      
      // Only admins can delete reports
      allow delete: if isAdmin();
    }
  }
}
