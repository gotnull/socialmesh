// SPDX-License-Identifier: GPL-3.0-or-later

import 'package:socialmesh/features/nodes/node_display_name_resolver.dart';

// Import Preview Model — conflict detection for NodeDex import/merge UX.
//
// When a user imports a NodeDex JSON file, entries may conflict with
// existing local data. This model provides a structured preview of
// what would change, which entries are new, and where conflicts exist
// in user-owned fields (socialTag, userNote).
//
// The preview is computed without modifying any state, allowing the
// user to review changes and choose a merge strategy before applying.

import 'nodedex_entry.dart';

/// Strategy for resolving conflicts during import.
enum MergeStrategy {
  /// Keep local values for socialTag and userNote when both exist.
  keepLocal,

  /// Prefer imported values for socialTag and userNote when both exist.
  preferImport,

  /// Review conflicts individually (used with per-entry overrides).
  reviewConflicts,
}

/// Describes a conflict between local and imported data for a single field.
class FieldConflict<T> {
  /// The current local value.
  final T localValue;

  /// The incoming imported value.
  final T importedValue;

  const FieldConflict({required this.localValue, required this.importedValue});
}

/// Describes the merge result for a single NodeDex entry.
class EntryMergePreview {
  /// The node number this preview is for.
  final int nodeNum;

  /// Display name hint (from live nodes or hex ID fallback).
  final String displayName;

  /// The local entry (null if this is a new entry).
  final NodeDexEntry? localEntry;

  /// The imported entry.
  final NodeDexEntry importedEntry;

  /// Conflict on socialTag (null if no conflict).
  final FieldConflict<NodeSocialTag?>? socialTagConflict;

  /// Conflict on userNote (null if no conflict).
  final FieldConflict<String?>? userNoteConflict;

  /// Whether the imported entry has a newer lastSeen.
  final bool importHasNewerData;

  /// Whether the imported entry has more encounters.
  final bool importHasMoreEncounters;

  /// Number of new co-seen edges the import would add.
  final int newCoSeenEdges;

  /// Number of new encounter records the import would add.
  final int newEncounterRecords;

  /// Number of new regions the import would add.
  final int newRegions;

  const EntryMergePreview({
    required this.nodeNum,
    required this.displayName,
    this.localEntry,
    required this.importedEntry,
    this.socialTagConflict,
    this.userNoteConflict,
    this.importHasNewerData = false,
    this.importHasMoreEncounters = false,
    this.newCoSeenEdges = 0,
    this.newEncounterRecords = 0,
    this.newRegions = 0,
  });

  /// Whether this is a brand new entry (not in local store).
  bool get isNew => localEntry == null;

  /// Whether this entry has any user-data conflicts.
  bool get hasConflicts =>
      socialTagConflict != null || userNoteConflict != null;

  /// Whether the import would change anything for this entry.
  bool get hasChanges =>
      isNew ||
      hasConflicts ||
      importHasNewerData ||
      importHasMoreEncounters ||
      newCoSeenEdges > 0 ||
      newEncounterRecords > 0 ||
      newRegions > 0;
}

/// Per-entry conflict resolution override.
///
/// When using [MergeStrategy.reviewConflicts], the user can specify
/// per-entry overrides for which value to keep.
class ConflictResolution {
  /// The node number this resolution is for.
  final int nodeNum;

  /// Whether to use the imported socialTag (true) or keep local (false).
  /// Null means use the global strategy.
  final bool? useSocialTagFromImport;

  /// Whether to use the imported userNote (true) or keep local (false).
  /// Null means use the global strategy.
  final bool? useUserNoteFromImport;

  const ConflictResolution({
    required this.nodeNum,
    this.useSocialTagFromImport,
    this.useUserNoteFromImport,
  });
}

/// Complete preview of an import operation.
///
/// Generated by analyzing the imported entries against the local store
/// without modifying any data. The user reviews this preview and
/// chooses a merge strategy before the import is applied.
class ImportPreview {
  /// All entry-level merge previews.
  final List<EntryMergePreview> entries;

  /// Total entries in the import file.
  final int totalImported;

  const ImportPreview({required this.entries, required this.totalImported});

  /// Number of entries that are brand new (not in local store).
  int get newEntryCount => entries.where((e) => e.isNew).length;

  /// Number of entries that would be merged with existing local data.
  int get mergeEntryCount => entries.where((e) => !e.isNew).length;

  /// Number of entries that have user-data conflicts.
  int get conflictCount => entries.where((e) => e.hasConflicts).length;

  /// Number of entries with socialTag conflicts.
  int get socialTagConflictCount =>
      entries.where((e) => e.socialTagConflict != null).length;

  /// Number of entries with userNote conflicts.
  int get userNoteConflictCount =>
      entries.where((e) => e.userNoteConflict != null).length;

  /// Whether there are any conflicts at all.
  bool get hasConflicts => conflictCount > 0;

  /// Whether the import has anything to apply.
  bool get hasChanges => entries.any((e) => e.hasChanges);

  /// Whether the import file was empty or invalid.
  bool get isEmpty => entries.isEmpty;

  /// Entries that have conflicts, sorted by node number.
  List<EntryMergePreview> get conflictingEntries =>
      entries.where((e) => e.hasConflicts).toList()
        ..sort((a, b) => a.nodeNum.compareTo(b.nodeNum));

  /// Entries that are new, sorted by node number.
  List<EntryMergePreview> get newEntries =>
      entries.where((e) => e.isNew).toList()
        ..sort((a, b) => a.nodeNum.compareTo(b.nodeNum));

  /// Entries that merge without conflicts, sorted by node number.
  List<EntryMergePreview> get cleanMergeEntries =>
      entries.where((e) => !e.isNew && !e.hasConflicts).toList()
        ..sort((a, b) => a.nodeNum.compareTo(b.nodeNum));

  /// Build an [ImportPreview] by analyzing imported entries against
  /// the local store contents.
  ///
  /// This is a pure function that does not modify any state.
  static ImportPreview build({
    required List<NodeDexEntry> importedEntries,
    required Map<int, NodeDexEntry> localEntries,
    String Function(int nodeNum)? displayNameResolver,
  }) {
    final previews = <EntryMergePreview>[];

    for (final imported in importedEntries) {
      final local = localEntries[imported.nodeNum];
      final displayName =
          displayNameResolver?.call(imported.nodeNum) ??
          NodeDisplayNameResolver.defaultName(imported.nodeNum);

      if (local == null) {
        // New entry — no conflicts possible.
        previews.add(
          EntryMergePreview(
            nodeNum: imported.nodeNum,
            displayName: displayName,
            localEntry: null,
            importedEntry: imported,
            newCoSeenEdges: imported.coSeenNodes.length,
            newEncounterRecords: imported.encounters.length,
            newRegions: imported.seenRegions.length,
          ),
        );
        continue;
      }

      // Existing entry — check for conflicts.
      FieldConflict<NodeSocialTag?>? tagConflict;
      if (local.socialTag != null &&
          imported.socialTag != null &&
          local.socialTag != imported.socialTag) {
        tagConflict = FieldConflict(
          localValue: local.socialTag,
          importedValue: imported.socialTag,
        );
      }

      FieldConflict<String?>? noteConflict;
      if (local.userNote != null &&
          imported.userNote != null &&
          local.userNote != imported.userNote) {
        noteConflict = FieldConflict(
          localValue: local.userNote,
          importedValue: imported.userNote,
        );
      }

      // Count new co-seen edges (edges in import but not in local).
      final newEdges = imported.coSeenNodes.keys
          .where((k) => !local.coSeenNodes.containsKey(k))
          .length;

      // Count new encounter records (by timestamp).
      final localTimestamps = local.encounters
          .map((e) => e.timestamp.millisecondsSinceEpoch)
          .toSet();
      final newEncounters = imported.encounters
          .where(
            (e) =>
                !localTimestamps.contains(e.timestamp.millisecondsSinceEpoch),
          )
          .length;

      // Count new regions.
      final localRegionIds = local.seenRegions.map((r) => r.regionId).toSet();
      final newRegionCount = imported.seenRegions
          .where((r) => !localRegionIds.contains(r.regionId))
          .length;

      previews.add(
        EntryMergePreview(
          nodeNum: imported.nodeNum,
          displayName: displayName,
          localEntry: local,
          importedEntry: imported,
          socialTagConflict: tagConflict,
          userNoteConflict: noteConflict,
          importHasNewerData: imported.lastSeen.isAfter(local.lastSeen),
          importHasMoreEncounters:
              imported.encounterCount > local.encounterCount,
          newCoSeenEdges: newEdges,
          newEncounterRecords: newEncounters,
          newRegions: newRegionCount,
        ),
      );
    }

    return ImportPreview(
      entries: previews,
      totalImported: importedEntries.length,
    );
  }

  /// Apply the import with the given strategy and optional per-entry
  /// conflict resolutions.
  ///
  /// Returns the list of final merged entries ready to be persisted.
  /// Does not modify state — the caller is responsible for saving.
  static List<NodeDexEntry> applyMerge({
    required ImportPreview preview,
    required Map<int, NodeDexEntry> localEntries,
    required MergeStrategy strategy,
    Map<int, ConflictResolution> resolutions = const {},
  }) {
    final results = <NodeDexEntry>[];

    for (final entryPreview in preview.entries) {
      final imported = entryPreview.importedEntry;
      final local = localEntries[entryPreview.nodeNum];

      if (local == null) {
        // New entry — add directly.
        results.add(imported);
        continue;
      }

      // Start with the standard merge (which defaults to local-wins
      // for socialTag and userNote).
      var merged = local.mergeWith(imported);

      // Apply strategy-based overrides for conflicting fields.
      final resolution = resolutions[entryPreview.nodeNum];

      // Resolve socialTag conflict.
      if (entryPreview.socialTagConflict != null) {
        final useImport =
            resolution?.useSocialTagFromImport ??
            (strategy == MergeStrategy.preferImport);
        if (useImport) {
          merged = merged.copyWith(socialTag: imported.socialTag);
        }
        // keepLocal is the default from mergeWith, no action needed.
      } else if (strategy == MergeStrategy.preferImport &&
          local.socialTag == null &&
          imported.socialTag != null) {
        // No conflict, but import has a value local doesn't — already
        // handled by mergeWith (fills from import when local is null).
      }

      // Resolve userNote conflict.
      if (entryPreview.userNoteConflict != null) {
        final useImport =
            resolution?.useUserNoteFromImport ??
            (strategy == MergeStrategy.preferImport);
        if (useImport) {
          merged = merged.copyWith(userNote: imported.userNote);
        }
        // keepLocal is the default from mergeWith, no action needed.
      }

      results.add(merged);
    }

    return results;
  }
}
